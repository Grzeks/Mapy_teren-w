<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Podświetlone budynki + ulice (zakres) – export PNG OK</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin:0; padding:0; }
    header { padding:8px; background:#222; color:#f5f5f5; }
    #controls { display:flex; gap:6px; align-items:center; flex-wrap:wrap; font-size:13px; }
    .flex-break { flex-basis: 100%; height: 0; }

    #adres  { min-width:260px; width:260px; padding:3px 6px; }
    #ulice  { min-width:240px; width:240px; padding:3px 6px; }
    #filename { min-width:160px; width:160px; padding:3px 6px; }

    #status { margin-top:6px; font-size:0.9em; color:#d0ffd0; }

    #map-container { position:relative; height:calc(100vh - 135px); width:100%; overflow:hidden; }
    #map { height:100%; width:100%; }

    #crop-frame {
      position: absolute;
      display: none;
      pointer-events: none;
      border: 3px solid rgba(255,165,0,0.85);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.15);
      background: transparent;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 100000;
    }

    #highlight-svg{
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:none; z-index:900;
    }

    button { padding:4px 8px; cursor:pointer; }
    input[type="color"] { width:34px; height:24px; padding:0; border:0; background:transparent; cursor:pointer; }
    input[type="range"] { width:90px; }
    label.inline { display:inline-flex; align-items:center; gap:4px; }
    .mono { font-variant-numeric: tabular-nums; }
  </style>
</head>

<body>
  <header>
    <div id="controls">
      <span>Adresy:</span>
      <input id="adres" type="text" value="" placeholder="np. Lodowa 54, 56" />

      <span>Kolor 1:</span>
      <input id="color-picker-1" type="color" value="#e73eea" />

      <span>Kolor 2:</span>
      <input id="color-picker-2" type="color" value="#0666e5" />

      <button id="btn-show">Pokaż budynki</button>

      <span>Nazwa:</span>
      <input id="filename" type="text" value="Teren_nr_" />

      <button id="btn-frame">Ramka 10x15</button>
      <button id="btn-save">Zapisz PNG</button>

      <div class="flex-break"></div>

      <span>Ulice:</span>
      <input id="ulice" type="text" value="" placeholder="np. Halna 1-77, Halna" />
      <button id="btn-streets">Pokaż ulice</button>

      <label class="inline">
        <input id="chk-streets" type="checkbox" checked />
        Czerwono
      </label>

      <label class="inline">Grubość:
        <input id="street-width" type="range" min="3" max="12" step="1" value="8" />
        <span id="street-width-val" class="mono">8</span>
      </label>

      <label class="inline">Przezr.:
        <input id="street-opacity" type="range" min="0.20" max="1.00" step="0.05" value="0.55" />
        <span id="street-opacity-val" class="mono">0.55</span>
      </label>

      <label class="inline">
        <input id="street-dash" type="checkbox" />
        Przerywana
      </label>
    </div>

    <div id="status"></div>
  </header>

  <div id="map-container">
    <div id="map"></div>
    <svg id="highlight-svg" aria-hidden="true"></svg>
    <div id="crop-frame"></div>
  </div>

<script>
  // =========================================================
  //  STAŁY ZOOM – ustaw tutaj:
  // =========================================================
  const FIXED_ZOOM = 17;
  const LOCK_ZOOM  = false;
  const DEFAULT_CITY = 'Łódź'; // zgodnie z Twoim użyciem
  // =========================================================

  // --- Inicjalizacja mapy ---
  const map = L.map('map', {
    minZoom: LOCK_ZOOM ? FIXED_ZOOM : 0,
    maxZoom: LOCK_ZOOM ? FIXED_ZOOM : 20
  }).setView([51.759, 19.456], FIXED_ZOOM);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 20,
    attribution: '© OpenStreetMap',
    crossOrigin: true
  }).addTo(map);

  // DOM
  const adresInput = document.getElementById('adres');
  const uliceInput = document.getElementById('ulice');
  const btnShow = document.getElementById('btn-show');
  const btnStreets = document.getElementById('btn-streets');
  const btnFrame = document.getElementById('btn-frame');
  const btnSave = document.getElementById('btn-save');
  const colorPicker1 = document.getElementById('color-picker-1');
  const colorPicker2 = document.getElementById('color-picker-2');
  const chkStreets = document.getElementById('chk-streets');
  const streetWidth = document.getElementById('street-width');
  const streetOpacity = document.getElementById('street-opacity');
  const streetDash = document.getElementById('street-dash');
  const streetWidthVal = document.getElementById('street-width-val');
  const streetOpacityVal = document.getElementById('street-opacity-val');

  let activeColorPicker = colorPicker1;
  const filenameInput = document.getElementById('filename');
  const statusEl = document.getElementById('status');
  const mapContainer = document.getElementById('map-container');
  const cropFrame = document.getElementById('crop-frame');
  const highlightSvg = document.getElementById('highlight-svg');

  function setStatus(text, isError = false) {
    statusEl.textContent = text;
    statusEl.style.color = isError ? '#ff8080' : '#d0ffd0';
  }
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  function qualifyCity(q) {
    const s = String(q || '').trim();
    const low = s.toLowerCase();
    if (low.includes('łódź') || low.includes('lodz') || low.includes(',')) return s;
    return `${DEFAULT_CITY}, ${s}`;
  }

  // --- Wymiary 10x15 cm @300dpi ---
  const DPI = 300;
  const CM_TO_INCH = 1/2.54;
  const TARGET_WIDTH_CM = 15;
  const TARGET_HEIGHT_CM = 10;
  const TARGET_WIDTH_PX = Math.round(TARGET_WIDTH_CM * CM_TO_INCH * DPI);
  const TARGET_HEIGHT_PX = Math.round(TARGET_HEIGHT_CM * CM_TO_INCH * DPI);
  const ratioWidth = TARGET_WIDTH_CM;
  const ratioHeight = TARGET_HEIGHT_CM;

  // --- Ramka: detach + pozycjonowanie ---
  let frameVisible = false;
  let cropFrameIsDetached = false;
  let cropFramePrevStyles = null;

  function computeFrameRectForContainer(containerRect) {
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const targetRatio = ratioWidth / ratioHeight;
    const margin = 0.85;
    const w = containerRect.width;
    const h = containerRect.height;
    let frameW, frameH;
    if (w && h) {
      if (w / h > targetRatio) {
        frameH = h * margin;
        frameW = frameH * targetRatio;
      } else {
        frameW = w * margin;
        frameH = frameW / targetRatio;
      }
    } else {
      if (vw / vh > targetRatio) {
        frameH = vh * margin;
        frameW = frameH * targetRatio;
      } else {
        frameW = vw * margin;
        frameH = frameW / targetRatio;
      }
    }
    const left = containerRect.left + (containerRect.width - frameW) / 2;
    const top  = containerRect.top  + (containerRect.height - frameH) / 2;
    return { frameW, frameH, left, top };
  }

  function detachCropFrameToBody() {
    if (cropFrameIsDetached) return;
    cropFramePrevStyles = {
      position: cropFrame.style.position || '',
      left: cropFrame.style.left || '',
      top: cropFrame.style.top || '',
      transform: cropFrame.style.transform || '',
      width: cropFrame.style.width || '',
      height: cropFrame.style.height || '',
      zIndex: cropFrame.style.zIndex || '',
      display: cropFrame.style.display || ''
    };
    document.body.appendChild(cropFrame);
    cropFrameIsDetached = true;
  }

  function reattachCropFrameToContainer() {
    if (!cropFrameIsDetached) return;
    mapContainer.appendChild(cropFrame);
    if (cropFramePrevStyles) {
      cropFrame.style.position = cropFramePrevStyles.position;
      cropFrame.style.left = cropFramePrevStyles.left;
      cropFrame.style.top = cropFramePrevStyles.top;
      cropFrame.style.transform = cropFramePrevStyles.transform;
      cropFrame.style.width = cropFramePrevStyles.width;
      cropFrame.style.height = cropFramePrevStyles.height;
      cropFrame.style.zIndex = cropFramePrevStyles.zIndex;
      cropFrame.style.display = cropFramePrevStyles.display;
    }
    cropFrameIsDetached = false;
    cropFramePrevStyles = null;
  }

  function updateCropFrame() {
    if (!frameVisible) return { ok: false };
    const contRect = mapContainer.getBoundingClientRect();
    const r = computeFrameRectForContainer(contRect);
    if (!r || !isFinite(r.frameW) || !isFinite(r.frameH)) return { ok: false };

    cropFrame.style.setProperty('display','block','important');
    cropFrame.style.setProperty('visibility','visible','important');
    cropFrame.style.setProperty('opacity','1','important');
    cropFrame.style.setProperty('z-index','2147483647','important');
    cropFrame.style.setProperty('border','3px solid orange','important');
    cropFrame.style.setProperty('box-shadow','0 0 0 9999px rgba(0,0,0,0.25)','important');

    detachCropFrameToBody();
    cropFrame.style.setProperty('position','fixed','important');
    cropFrame.style.setProperty('left', Math.round(r.left) + 'px','important');
    cropFrame.style.setProperty('top', Math.round(r.top) + 'px','important');
    cropFrame.style.setProperty('width', Math.round(r.frameW) + 'px','important');
    cropFrame.style.setProperty('height', Math.round(r.frameH) + 'px','important');
    cropFrame.style.setProperty('transform','none','important');

    return { ok: true, rect: r };
  }

  function ensureCropVisible() {
    const rect = cropFrame.getBoundingClientRect();
    const cs = window.getComputedStyle(cropFrame);
    if (cs.display === 'none' || rect.width === 0 || rect.height === 0) {
      cropFrame.style.setProperty('position','fixed','important');
      cropFrame.style.setProperty('left','50%','important');
      cropFrame.style.setProperty('top','50%','important');
      cropFrame.style.setProperty('transform','translate(-50%,-50%)','important');
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      const margin = 0.85; const ratio = 15/10;
      let fw, fh;
      if (vw/vh > ratio) { fh = vh*margin; fw = fh*ratio; } else { fw = vw*margin; fh = fw/ratio; }
      cropFrame.style.setProperty('width', Math.round(fw)+'px','important');
      cropFrame.style.setProperty('height', Math.round(fh)+'px','important');
      cropFrame.style.setProperty('z-index','2147483647','important');
    }
  }

  function showFrame() {
    frameVisible = true;
    cropFrame.style.setProperty('display','block','important');
    cropFrame.style.setProperty('visibility','visible','important');
    cropFrame.style.setProperty('opacity','1','important');
    requestAnimationFrame(() => {
      updateCropFrame();
      ensureCropVisible();
    });
    btnFrame.textContent = 'Ukryj ramkę';
  }

  function hideFrame() {
    frameVisible = false;
    reattachCropFrameToContainer();
    cropFrame.style.setProperty('display','none','important');
    btnFrame.textContent = 'Ramka 10x15';
  }

  btnFrame.addEventListener('click', () => { if (frameVisible) hideFrame(); else showFrame(); });
  map.on('move zoom', () => { if (frameVisible) updateCropFrame(); });
  window.addEventListener('resize', () => { if (frameVisible) updateCropFrame(); });

  // --- Highlight SVG: budynki + ulice ---
  let buildingRings = [];
  let streetSegments = []; // tablice: [ [lat,lon], ... ]

  function clearHighlight() {
    buildingRings = [];
    while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
  }

  function clearStreets() {
    streetSegments = [];
    updateHighlightSvg();
  }

  function hexToRgba(hex, alpha = 0.35) {
    const c = hex.replace('#','');
    const bigint = parseInt(c, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r},${g},${b},${alpha})`;
  }
  function getActiveColor() {
    return (activeColorPicker && activeColorPicker.value) || '#b36b00';
  }

  function updateHighlightSvg() {
    while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);

    // ===== B U D Y N K I =====
    if (buildingRings.length) {
      const color = getActiveColor();
      const fill = hexToRgba(color, 0.35);
      const stroke = color;

      for (const ring of buildingRings) {
        if (!ring || ring.length < 3) continue;
        const pts = ring.map(([la, lo]) => {
          const p = map.latLngToContainerPoint([la, lo]);
          return `${p.x},${p.y}`;
        }).join(' ');

        const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute('points', pts);
        poly.setAttribute('fill', fill);
        poly.setAttribute('stroke', stroke);
        poly.setAttribute('stroke-width', '3');
        highlightSvg.appendChild(poly);
      }
    }

    // ===== U L I C E (SVG -> zapis do PNG) =====
    if (chkStreets.checked && streetSegments.length) {
      const w = parseInt(streetWidth.value, 10) || 8;
      const op = parseFloat(streetOpacity.value) || 0.55;
      const dashed = !!streetDash.checked;

      const dashA = Math.max(10, Math.round(w * 2.6));
      const dashB = Math.max(6,  Math.round(w * 1.6));
      const dashStr = `${dashA} ${dashB}`;

      for (const seg of streetSegments) {
        if (!seg || seg.length < 2) continue;

        const pts = seg.map(([la, lo]) => {
          const p = map.latLngToContainerPoint([la, lo]);
          return `${p.x},${p.y}`;
        }).join(' ');

        const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
        pl.setAttribute('points', pts);
        pl.setAttribute('fill', 'none');
        pl.setAttribute('stroke', '#ff0000');
        pl.setAttribute('stroke-width', String(w));
        pl.setAttribute('stroke-opacity', String(op));
        pl.setAttribute('stroke-linecap', 'round');
        pl.setAttribute('stroke-linejoin', 'round');
        if (dashed) pl.setAttribute('stroke-dasharray', dashStr);

        highlightSvg.appendChild(pl);
      }
    }
  }

  map.on('move zoom', updateHighlightSvg);

  // --- UI: suwaki ulic ---
  function syncStreetUi() {
    streetWidthVal.textContent = streetWidth.value;
    streetOpacityVal.textContent = Number(streetOpacity.value).toFixed(2);
    updateHighlightSvg();
  }
  streetWidth.addEventListener('input', syncStreetUi);
  streetOpacity.addEventListener('input', syncStreetUi);
  streetDash.addEventListener('change', syncStreetUi);
  chkStreets.addEventListener('change', syncStreetUi);
  syncStreetUi();

  // --- pole wielokąta (approx) ---
  function polygonAreaApprox(coords) {
    let area = 0;
    for (let i = 0; i < coords.length; i++) {
      const [y1, x1] = coords[i];
      const [y2, x2] = coords[(i + 1) % coords.length];
      area += x1 * y2 - x2 * y1;
    }
    return Math.abs(area) / 2;
  }

  // --- Geocoding + Overpass ---
  async function geocode(address) {
    const url = 'https://nominatim.openstreetmap.org/search?' +
      new URLSearchParams({ format:'json', limit:'1', q: address, polygon_geojson: 1 });
    const resp = await fetch(url, { headers: { 'Accept-Language': 'pl' } });
    if (!resp.ok) throw new Error('Błąd geokodowania');
    const data = await resp.json();
    if (!data.length) return null;
    return [parseFloat(data[0].lat), parseFloat(data[0].lon), data[0]];
  }

  async function fetchBuildingWays(lat, lon, radius = 60) {
    const query = `
[out:json][timeout:25];
(
  way["building"](around:${radius},${lat},${lon});
  relation["building"](around:${radius},${lat},${lon});
);
(._;>;);
out body;
`;
    const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
    if (!resp.ok) throw new Error('Błąd Overpass');
    const data = await resp.json();
    return data.elements || [];
  }

  function normalize(s='') {
    return String(s).trim().toLowerCase()
      .replace(/\./g,'')
      .replace(/\b(ulica|ul|al|aleja|al\.)\b/g,'')
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .replace(/\s+/g,' ').trim();
  }

  function pointInRing(lon, lat, ring) {
    let inside = false;
    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      const xi = ring[i][1], yi = ring[i][0];
      const xj = ring[j][1], yj = ring[j][0];
      const intersect = ((yi > lat) !== (yj > lat)) &&
        (lon < (xj - xi) * (lat - yi) / (yj - yi + 0.0) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // "Ulica 123" -> "Ulica"
  function extractStreet(s) {
    const m = String(s).trim().match(/^(.+?)\s+\d/);
    return m ? m[1].trim() : null;
  }

  // =========================================================
  //  U L I C E (zakres od-do / cała ulica)
  // =========================================================
  function opEscape(s) {
    return String(s).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  }
  function boundsToBboxObj(bounds) {
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    return { south: sw.lat, west: sw.lng, north: ne.lat, east: ne.lng };
  }

  async function fetchHighwayWaysByNameBBox(streetName, bbox) {
    const { south, west, north, east } = bbox;
    const nn = opEscape(streetName);
    const query = `
[out:json][timeout:25];
(
  way["highway"]["name"="${nn}"](${south},${west},${north},${east});
);
out geom;
`;
    const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
    if (!resp.ok) throw new Error('Błąd Overpass (ulice)');
    const data = await resp.json();
    return (data.elements || []).filter(e => e.type === 'way' && Array.isArray(e.geometry) && e.geometry.length >= 2);
  }

  // zakresy + sama ulica
  function parseStreetRanges(raw) {
    const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
    const out = [];

    for (const p of parts) {
      // zakres: "Ulica 1-77" / "Ulica 1 do 77"
      const m = p.match(/^(.*?)(\d+[A-Za-z0-9\/\-]*)\s*(?:-|–|—|\bdo\b)\s*(\d+[A-Za-z0-9\/\-]*)\s*$/i);
      if (m) {
        const street = m[1].trim();
        const from = m[2].trim();
        const to = m[3].trim();
        if (street && from && to) out.push({ mode:'range', street, from, to, raw: p });
        continue;
      }

      // sama ulica: "Halna" / "ul. Halna"
      const streetOnly = p.replace(/^\s*(ulica|ul\.?)\s+/i, '').trim();
      if (streetOnly && !/\d/.test(streetOnly)) {
        out.push({ mode:'full', street: streetOnly, raw: p });
      }
    }

    return out;
  }

  // haversine
  function distMeters(a, b) {
    const R = 6371000;
    const toRad = (d) => d * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lng - a.lng);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);
    const sin1 = Math.sin(dLat/2), sin2 = Math.sin(dLon/2);
    const h = sin1*sin1 + Math.cos(lat1)*Math.cos(lat2)*sin2*sin2;
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
  }

  // projekcja punktu na odcinek (aproksymacja equirect)
  function projectPointToSegment(P, A, B) {
    const R = 6371000;
    const lat0 = (A.lat + B.lat + P.lat) / 3 * Math.PI/180;
    const cos0 = Math.cos(lat0);

    const toXY = (ll) => {
      const x = (ll.lng * Math.PI/180) * R * cos0;
      const y = (ll.lat * Math.PI/180) * R;
      return { x, y };
    };
    const toLL = (x, y) => {
      const lat = (y / R) * 180/Math.PI;
      const lng = (x / (R * cos0)) * 180/Math.PI;
      return L.latLng(lat, lng);
    };

    const p = toXY(P), a = toXY(A), b = toXY(B);
    const abx = b.x - a.x, aby = b.y - a.y;
    const apx = p.x - a.x, apy = p.y - a.y;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 ? (apx*abx + apy*aby) / ab2 : 0;
    t = Math.max(0, Math.min(1, t));
    const x = a.x + t*abx;
    const y = a.y + t*aby;
    const proj = toLL(x, y);
    const d = Math.hypot(p.x - x, p.y - y);
    return { proj, t, d };
  }

  function toKey(ll) { return `${ll.lat.toFixed(6)},${ll.lng.toFixed(6)}`; }

  class MinHeap {
    constructor() { this.a = []; }
    push(item) { this.a.push(item); this._up(this.a.length - 1); }
    pop() {
      if (!this.a.length) return null;
      const top = this.a[0];
      const last = this.a.pop();
      if (this.a.length) { this.a[0] = last; this._down(0); }
      return top;
    }
    _up(i) {
      while (i > 0) {
        const p = (i - 1) >> 1;
        if (this.a[p].d <= this.a[i].d) break;
        [this.a[p], this.a[i]] = [this.a[i], this.a[p]];
        i = p;
      }
    }
    _down(i) {
      const n = this.a.length;
      for (;;) {
        let l = i*2+1, r = l+1, m = i;
        if (l < n && this.a[l].d < this.a[m].d) m = l;
        if (r < n && this.a[r].d < this.a[m].d) m = r;
        if (m === i) break;
        [this.a[m], this.a[i]] = [this.a[i], this.a[m]];
        i = m;
      }
    }
  }

  function dijkstra(adj, startK, endK) {
    const dist = new Map();
    const prev = new Map();
    const heap = new MinHeap();

    dist.set(startK, 0);
    heap.push({ k: startK, d: 0 });

    while (true) {
      const cur = heap.pop();
      if (!cur) break;
      const { k, d } = cur;
      if (d !== dist.get(k)) continue;
      if (k === endK) break;

      const nbrs = adj.get(k);
      if (!nbrs) continue;

      for (const { to, w } of nbrs) {
        const nd = d + w;
        if (nd < (dist.get(to) ?? Infinity)) {
          dist.set(to, nd);
          prev.set(to, k);
          heap.push({ k: to, d: nd });
        }
      }
    }

    if (!dist.has(endK)) return null;

    const path = [];
    let k = endK;
    while (k != null) {
      path.push(k);
      if (k === startK) break;
      k = prev.get(k);
    }
    path.reverse();
    return path;
  }

  // fallback numerów: jeśli np. "77" nie istnieje -> cofamy (76..71..)
  function splitHouseNo(h) {
    const m = String(h).trim().match(/^(\d+)(.*)$/);
    if (!m) return null;
    return { n: parseInt(m[1], 10), rest: (m[2] || '').trim() };
  }

  async function geocodeWithFallback(street, house, tryDown = true, maxSteps = 30) {
    const base = qualifyCity(`${street} ${house}`);
    let g = await geocode(base);
    if (g) return { geo: g, usedHouse: house, fallback: false };

    const sp = splitHouseNo(house);
    if (!sp) return { geo: null, usedHouse: house, fallback: false };

    for (let i = 1; i <= maxSteps; i++) {
      const nn = tryDown ? (sp.n - i) : (sp.n + i);
      if (nn <= 0) break;

      const candidate = `${nn}${sp.rest ? sp.rest : ''}`.trim();
      g = await geocode(qualifyCity(`${street} ${candidate}`));
      if (g) return { geo: g, usedHouse: candidate, fallback: true };
    }

    return { geo: null, usedHouse: house, fallback: false };
  }

  let lastStreetRequestId = 0;

  async function highlightWholeStreet(streetName, requestId) {
    const bounds = map.getBounds().pad(0.60);
    const bbox = boundsToBboxObj(bounds);

    const ways = await fetchHighwayWaysByNameBBox(streetName, bbox);
    if (requestId !== lastStreetRequestId) return null;
    if (!ways.length) return { ok:false, reason:`Brak geometrii OSM dla: ${streetName}` };

    let merged = null;

    for (const w of ways) {
      const pts = w.geometry.map(p => [p.lat, p.lon]);
      if (pts.length < 2) continue;

      streetSegments.push(pts);

      const b = L.latLngBounds(pts.map(pp => L.latLng(pp[0], pp[1])));
      merged = merged ? merged.extend(b) : b;
    }

    updateHighlightSvg();
    return { ok:true, bounds: merged };
  }

  async function highlightOneStreetRange(range, requestId) {
    const street = range.street;

    // od: próbujemy normalnie, a jak brak -> można iść w górę trochę
    const r1 = await geocodeWithFallback(street, range.from, false, 15);
    if (requestId !== lastStreetRequestId) return null;

    // do: jak brak -> cofamy w dół (np. 77 -> 71)
    const r2 = await geocodeWithFallback(street, range.to, true, 40);
    if (requestId !== lastStreetRequestId) return null;

    if (!r1.geo || !r2.geo) return { ok:false, reason:`Brak geokodowania: ${range.raw}` };

    const p1 = L.latLng(r1.geo[0], r1.geo[1]);
    const p2 = L.latLng(r2.geo[0], r2.geo[1]);

    const bounds = L.latLngBounds([p1, p2]).pad(0.55);
    const bbox = boundsToBboxObj(bounds);

    const ways = await fetchHighwayWaysByNameBBox(street, bbox);
    if (requestId !== lastStreetRequestId) return null;
    if (!ways.length) return { ok:false, reason:`Brak geometrii OSM dla: ${street}` };

    // graf
    const adj = new Map();
    const coordsByKey = new Map();

    function ensureNode(ll) {
      const k = toKey(ll);
      if (!coordsByKey.has(k)) coordsByKey.set(k, ll);
      if (!adj.has(k)) adj.set(k, []);
      return k;
    }
    function addEdge(k1, k2, w) { adj.get(k1).push({ to: k2, w }); }

    for (const w of ways) {
      const pts = w.geometry.map(p => L.latLng(p.lat, p.lon));
      for (let i = 0; i < pts.length - 1; i++) {
        const A = pts[i], B = pts[i+1];
        const kA = ensureNode(A);
        const kB = ensureNode(B);
        const wAB = distMeters(A, B);
        addEdge(kA, kB, wAB);
        addEdge(kB, kA, wAB);
      }
    }

    function findBestProjection(P) {
      let best = null;
      for (const w of ways) {
        const pts = w.geometry.map(p => L.latLng(p.lat, p.lon));
        for (let i = 0; i < pts.length - 1; i++) {
          const A = pts[i], B = pts[i+1];
          const pr = projectPointToSegment(P, A, B);
          if (!best || pr.d < best.d) best = { ...pr, A, B };
        }
      }
      return best;
    }

    const pr1 = findBestProjection(p1);
    const pr2 = findBestProjection(p2);
    if (!pr1 || !pr2) return { ok:false, reason:`Nie udało się dopasować odcinka: ${range.raw}` };

    const kA1 = ensureNode(pr1.A);
    const kB1 = ensureNode(pr1.B);
    const kP1 = ensureNode(pr1.proj);

    const kA2 = ensureNode(pr2.A);
    const kB2 = ensureNode(pr2.B);
    const kP2 = ensureNode(pr2.proj);

    const wP1A = distMeters(pr1.proj, pr1.A), wP1B = distMeters(pr1.proj, pr1.B);
    addEdge(kP1, kA1, wP1A); addEdge(kA1, kP1, wP1A);
    addEdge(kP1, kB1, wP1B); addEdge(kB1, kP1, wP1B);

    const wP2A = distMeters(pr2.proj, pr2.A), wP2B = distMeters(pr2.proj, pr2.B);
    addEdge(kP2, kA2, wP2A); addEdge(kA2, kP2, wP2A);
    addEdge(kP2, kB2, wP2B); addEdge(kB2, kP2, wP2B);

    const pathKeys = dijkstra(adj, kP1, kP2);
    if (!pathKeys || pathKeys.length < 2) return { ok:false, reason:`Brak ścieżki po ulicy: ${range.raw}` };

    const path = pathKeys.map(k => coordsByKey.get(k)).filter(Boolean).map(ll => [ll.lat, ll.lng]);

    streetSegments.push(path);
    updateHighlightSvg();

    return {
      ok:true,
      path,
      usedFrom: r1.usedHouse,
      usedTo: r2.usedHouse,
      fallbackUsed: (r1.fallback || r2.fallback)
    };
  }

  async function showStreetsRanges() {
    const raw = uliceInput.value.trim();
    if (!raw) { setStatus('Podaj ulicę: "Halna" albo zakres "Halna 1-77".', true); return; }

    const ranges = parseStreetRanges(raw);
    if (!ranges.length) {
      setStatus('Nie rozpoznano wpisu. Format: "Ulica 10-20, Inna" (bez numerów = cała ulica).', true);
      return;
    }

    clearStreets();
    chkStreets.checked = true;

    const requestId = ++lastStreetRequestId;
    setStatus(`Rysuję ulice: ${ranges.length}…`);

    let drawn = 0, fail = 0, fallbackCount = 0;
    let merged = null;

    for (const r of ranges) {
      try {
        let res = null;

        if (r.mode === 'range') {
          res = await highlightOneStreetRange(r, requestId);
          if (requestId !== lastStreetRequestId) return;

          if (res && res.ok && res.path) {
            drawn++;
            if (res.fallbackUsed) fallbackCount++;
            const b = L.latLngBounds(res.path.map(p => L.latLng(p[0], p[1])));
            merged = merged ? merged.extend(b) : b;
          } else {
            fail++;
          }
        }

        if (r.mode === 'full') {
          res = await highlightWholeStreet(r.street, requestId);
          if (requestId !== lastStreetRequestId) return;

          if (res && res.ok && res.bounds) {
            drawn++;
            merged = merged ? merged.extend(res.bounds) : res.bounds;
          } else {
            fail++;
          }
        }

      } catch (e) {
        fail++;
      }

      await sleep(180);
    }

    if (!drawn) { setStatus('Nie udało się narysować żadnego zakresu/ulicy.', true); return; }

    map.setView(merged.getCenter(), FIXED_ZOOM, { animate: true });
    updateHighlightSvg();

    const extra = fallbackCount ? ` (fallback: ${fallbackCount})` : '';
    setStatus(`Ulice OK: ${drawn}, błędy: ${fail}${extra}.`);
  }

  btnStreets.addEventListener('click', showStreetsRanges);
  uliceInput.addEventListener('keydown', e => { if (e.key === 'Enter') showStreetsRanges(); });

  // =========================================================
  //  B U D Y N K I – jak było
  // =========================================================
  let lastRequestId = 0;

  async function showBuildingsForAddresses() {
    const raw = adresInput.value.trim();
    if (!raw) { setStatus('Podaj adresy.', true); return; }

    setStatus('Szukam budynków…');
    clearHighlight();
    const myId = ++lastRequestId;

    const segments = raw.split(',').map(s => s.trim()).filter(Boolean);

    const addresses = [];
    let lastStreet = null;

    const isHouseNumberOnly = (s) =>
      /^\d+[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż0-9\-\/]*$/.test(s);

    const looksLikeStreetAndNumber = (s) =>
      /[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż]/.test(s) && /\d/.test(s) && !!extractStreet(s);

    for (const part of segments) {
      if (looksLikeStreetAndNumber(part)) {
        const st = extractStreet(part);
        if (st) lastStreet = st;
        addresses.push(part);
        continue;
      }
      if (lastStreet && isHouseNumberOnly(part)) {
        addresses.push(`${lastStreet} ${part}`);
        continue;
      }
      addresses.push(part);
    }

    const finalAddresses = addresses.map(a => qualifyCity(a));

    for (const addr of finalAddresses) {
      try {
        const geo = await geocode(addr);
        if (!geo) { continue; }
        const center = [geo[0], geo[1]];
        const nomiObj = geo[2];
        if (myId !== lastRequestId) return;

        // --- Nominatim polygon tylko gdy NIE jest to Bartoka 1 ---
        let usedFromNominatim = false;
        if (nomiObj && nomiObj.geojson && !/bartoka\s+1\b/i.test(addr)) {
          const g = nomiObj.geojson;
          if (g.type === 'Polygon') {
            const ring = g.coordinates[0].map(([lon, lat]) => [lat, lon]);
            buildingRings.push(ring);
            usedFromNominatim = true;
          } else if (g.type === 'MultiPolygon') {
            for (const poly of g.coordinates) {
              const ring = poly[0].map(([lon, lat]) => [lat, lon]);
              buildingRings.push(ring);
            }
            usedFromNominatim = true;
          }
          if (usedFromNominatim) {
            if (myId !== lastRequestId) return;
            continue;
          }
        }

        // --- Overpass ---
        const elems = await fetchBuildingWays(center[0], center[1], 60);
        if (myId !== lastRequestId) return;
        if (!elems.length) { continue; }

        const nodeMap = new Map();
        for (const el of elems) if (el.type === 'node') nodeMap.set(el.id, [el.lat, el.lon]);

        const rings = [];
        const ways = elems.filter(el => el.type === 'way');
        for (const w of ways) {
          const coords = w.nodes.map(id => nodeMap.get(id)).filter(Boolean);
          if (coords.length >= 3) {
            rings.push({ coords, tags: w.tags || {}, area: polygonAreaApprox(coords) });
          }
        }

        const relations = elems.filter(el => el.type === 'relation' && el.tags && (el.tags.type === 'multipolygon' || el.tags.building));
        for (const rel of relations) {
          if (!rel.members) continue;
          const outerMembers = rel.members.filter(m => m.type === 'way' && (m.role === 'outer' || m.role === ''));
          for (const m of outerMembers) {
            const way = elems.find(e => e.type === 'way' && e.id === m.ref);
            if (!way) continue;
            const coords = way.nodes.map(id => nodeMap.get(id)).filter(Boolean);
            if (coords.length >= 3) {
              rings.push({ coords, tags: way.tags || {}, area: polygonAreaApprox(coords) });
            }
          }
        }

        if (rings.length === 0) { continue; }

        const m = addr.match(/(.*)\s+(\d+[a-zA-Z0-9\-\/]*)$/);
        const wanted = {};
        if (m) { wanted.street = normalize(m[1]); wanted.number = normalize(m[2]); }

        const matches = [];
        for (const r of rings) {
          const tags = r.tags || {};
          let accept = false;

          if (tags['addr:housenumber'] || tags['addr:street']) {
            const tagNum = normalize(tags['addr:housenumber'] || '');
            const tagStreet = normalize(tags['addr:street'] || tags['addr:street:name'] || '');
            if (wanted.number && wanted.street && tagNum === wanted.number && tagStreet === wanted.street) {
              accept = true;
            }
          }
          if (!accept) {
            if (pointInRing(center[1], center[0], r.coords)) accept = true;
          }
          if (accept) matches.push(r);
        }

        let finalPicked = [];

        if (matches.length) {
          if (wanted.street === 'bartoka' && wanted.number === '1') {
            let largest = matches[0];
            for (const r of matches) if (r.area > largest.area) largest = r;
            finalPicked = [largest.coords];
          } else {
            finalPicked = matches.map(r => r.coords);
          }
        } else {
          const wayInfos = rings.map(rr => {
            const coords = rr.coords;
            let sumLat=0,sumLon=0;
            for (const [la,lo] of coords){ sumLat+=la; sumLon+=lo; }
            const cLat = sumLat/coords.length, cLon = sumLon/coords.length;
            const dLat = cLat - center[0], dLon = cLon - center[1];
            return { coords, dist2: dLat*dLat + dLon*dLon };
          }).sort((a,b)=>a.dist2-b.dist2);
          if (wayInfos.length) finalPicked.push(wayInfos[0].coords);
        }

        for (const p of finalPicked) buildingRings.push(p);

      } catch (err) {
        // cicho
      }
    }

    if (!buildingRings.length) {
      setStatus('Nie znaleziono budynków dla podanych adresów.', true);
      return;
    }

    updateHighlightSvg();

    const tmpPoly = L.polygon([].concat(...buildingRings));
    const focusBounds = tmpPoly.getBounds();
    map.setView(focusBounds.getCenter(), FIXED_ZOOM, { animate: true });

    setStatus(`Budynki: ${buildingRings.length} (${addresses.length} adresów).`);
  }

  btnShow.addEventListener('click', async () => {
    clearHighlight();
    await showBuildingsForAddresses();
  });

  adresInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      clearHighlight();
      showBuildingsForAddresses();
    }
  });

  // --- Eksport PNG 10x15 cm @300 DPI ---
  const HTML2CANVAS_SCALE = 3;

  async function saveFramePng() {
    if (!frameVisible) { setStatus('Najpierw włącz ramkę.', true); return; }
    try {
      setStatus('Generuję PNG…');
      const fullCanvas = await html2canvas(mapContainer, { useCORS: true, logging: false, scale: HTML2CANVAS_SCALE });

      const frameRect = cropFrame.getBoundingClientRect();
      const contRect = mapContainer.getBoundingClientRect();

      const sx = frameRect.left - contRect.left;
      const sy = frameRect.top  - contRect.top;
      const sw = frameRect.width;
      const sh = frameRect.height;

      const scaleX = fullCanvas.width  / mapContainer.clientWidth;
      const scaleY = fullCanvas.height / mapContainer.clientHeight;

      const sxScaled = sx * scaleX;
      const syScaled = sy * scaleY;
      const swScaled = sw * scaleX;
      const shScaled = sh * scaleY;

      const outCanvas = document.createElement('canvas');
      outCanvas.width = TARGET_WIDTH_PX;
      outCanvas.height = TARGET_HEIGHT_PX;
      const ctx = outCanvas.getContext('2d');

      ctx.drawImage(fullCanvas, sxScaled, syScaled, swScaled, shScaled, 0, 0, TARGET_WIDTH_PX, TARGET_HEIGHT_PX);

      const dataUrl = outCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataUrl;

      let baseName = (filenameInput.value || 'map_10x15cm_300dpi').trim();
      if (!baseName.toLowerCase().endsWith('.png')) baseName += '.png';
      a.download = baseName;

      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      setStatus('Zapisano PNG.');
    } catch (err) {
      setStatus('Błąd tworzenia PNG (fallback: ręczny zrzut).', true);
    }
  }

  btnSave.addEventListener('click', saveFramePng);

  function handleColorInput(e) {
    activeColorPicker = e.target;
    updateHighlightSvg();
  }
  colorPicker1.addEventListener('input', handleColorInput);
  colorPicker2.addEventListener('input', handleColorInput);
  colorPicker1.addEventListener('click', () => { activeColorPicker = colorPicker1; updateHighlightSvg(); });
  colorPicker2.addEventListener('click', () => { activeColorPicker = colorPicker2; updateHighlightSvg(); });

</script>
</body>
</html>
