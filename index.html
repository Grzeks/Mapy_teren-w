<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Podświetlone budynki – final (precyzyjne dopasowanie)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin:0; padding:0; }
    header { padding:10px; background:#222; color:#f5f5f5; }
    #controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    /* łamacz linii – wszystko poniżej wchodzi w drugi rząd */
    .flex-break {
      flex-basis: 100%;
      height: 0;
    }

    #adres { min-width:320px; padding:4px 8px; }
    #filename { min-width:220px; padding:4px 8px; }
    #status { margin-top:6px; font-size:0.9em; color:#d0ffd0; }
    #map-container { position:relative; height:calc(100vh - 120px); width:100%; overflow:hidden; }
    #map { height:100%; width:100%; }

    /* Domyślne style ramki */
    #crop-frame {
      position: absolute;
      display: none;
      pointer-events: none;
      border: 3px solid rgba(255,165,0,0.85);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.15);
      background: transparent;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 100000;
    }

    #highlight-svg {
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:none; z-index:900;
    }

    button { padding:6px 10px; cursor:pointer; }
    input[type="color"] { width:36px; height:28px; padding:0; border:0; background:transparent; cursor:pointer; }
    label.inline { display:inline-flex; align-items:center; gap:6px; }
  </style>
</head>
<body>
  <header>
    <div id="controls">
      <span>Adresy (max 6, oddzielone przecinkami):</span>
      <input id="adres" type="text" value="" />

      <label class="inline">Kolor 1:
        <input id="color-picker-1" type="color" value="#e73eea" />
      </label>

      <label class="inline">Kolor 2:
        <input id="color-picker-2" type="color" value="#0666e5" />
      </label>

      <label class="inline">Nazwa pliku:
        <input id="filename" type="text" value="Teren_nr_" />
      </label>

      <div class="flex-break"></div>

      <button id="btn-show">Pokaż budynki</button>
      <button id="btn-frame">Pokaż ramkę 10x15 cm</button>
      <button id="btn-save">Zapisz PNG (300 DPI)</button>
    </div>
    <div id="status"></div>
  </header>

  <div id="map-container">
    <div id="map"></div>
    <svg id="highlight-svg" aria-hidden="true"></svg>
    <div id="crop-frame"></div>
  </div>

  <script>
    // --- Inicjalizacja mapy ---
    const map = L.map('map').setView([51.759, 19.456], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20,
      attribution: '© OpenStreetMap',
      crossOrigin: true
    }).addTo(map);

    // DOM
    const adresInput = document.getElementById('adres');
    const btnShow = document.getElementById('btn-show');
    const btnFrame = document.getElementById('btn-frame');
    const btnSave = document.getElementById('btn-save');
    const colorPicker1 = document.getElementById('color-picker-1');
    const colorPicker2 = document.getElementById('color-picker-2');
    let activeColorPicker = colorPicker1; // domyślnie Kolor 1
    const filenameInput = document.getElementById('filename');
    const statusEl = document.getElementById('status');
    const mapContainer = document.getElementById('map-container');
    const cropFrame = document.getElementById('crop-frame');
    const highlightSvg = document.getElementById('highlight-svg');

    function setStatus(text, isError = false) {
      statusEl.textContent = text;
      statusEl.style.color = isError ? '#ff8080' : '#d0ffd0';
    }

    // --- Wymiary 10x15 cm @300dpi ---
    const DPI = 300;
    const CM_TO_INCH = 1/2.54;
    const TARGET_WIDTH_CM = 15;
    const TARGET_HEIGHT_CM = 10;
    const TARGET_WIDTH_PX = Math.round(TARGET_WIDTH_CM * CM_TO_INCH * DPI);
    const TARGET_HEIGHT_PX = Math.round(TARGET_HEIGHT_CM * CM_TO_INCH * DPI);
    const ratioWidth = TARGET_WIDTH_CM;
    const ratioHeight = TARGET_HEIGHT_CM;

    // --- Ramka: detach + pozycjonowanie ---
    let frameVisible = false;
    let cropFrameIsDetached = false;
    let cropFramePrevStyles = null;

    function computeFrameRectForContainer(containerRect) {
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      const targetRatio = ratioWidth / ratioHeight;
      const margin = 0.85;
      const w = containerRect.width;
      const h = containerRect.height;
      let frameW, frameH;
      if (w && h) {
        if (w / h > targetRatio) {
          frameH = h * margin;
          frameW = frameH * targetRatio;
        } else {
          frameW = w * margin;
          frameH = frameW / targetRatio;
        }
      } else {
        if (vw / vh > targetRatio) {
          frameH = vh * margin;
          frameW = frameH * targetRatio;
        } else {
          frameW = vw * margin;
          frameH = frameW / targetRatio;
        }
      }
      const left = containerRect.left + (containerRect.width - frameW) / 2;
      const top  = containerRect.top  + (containerRect.height - frameH) / 2;
      return { frameW, frameH, left, top };
    }

    function detachCropFrameToBody() {
      if (cropFrameIsDetached) return;
      cropFramePrevStyles = {
        position: cropFrame.style.position || '',
        left: cropFrame.style.left || '',
        top: cropFrame.style.top || '',
        transform: cropFrame.style.transform || '',
        width: cropFrame.style.width || '',
        height: cropFrame.style.height || '',
        zIndex: cropFrame.style.zIndex || '',
        display: cropFrame.style.display || ''
      };
      document.body.appendChild(cropFrame);
      cropFrameIsDetached = true;
    }

    function reattachCropFrameToContainer() {
      if (!cropFrameIsDetached) return;
      mapContainer.appendChild(cropFrame);
      if (cropFramePrevStyles) {
        cropFrame.style.position = cropFramePrevStyles.position;
        cropFrame.style.left = cropFramePrevStyles.left;
        cropFrame.style.top = cropFramePrevStyles.top;
        cropFrame.style.transform = cropFramePrevStyles.transform;
        cropFrame.style.width = cropFramePrevStyles.width;
        cropFrame.style.height = cropFramePrevStyles.height;
        cropFrame.style.zIndex = cropFramePrevStyles.zIndex;
        cropFrame.style.display = cropFramePrevStyles.display;
      }
      cropFrameIsDetached = false;
      cropFramePrevStyles = null;
    }

    function updateCropFrame() {
      if (!frameVisible) return { ok: false };
      const contRect = mapContainer.getBoundingClientRect();
      const r = computeFrameRectForContainer(contRect);
      if (!r || !isFinite(r.frameW) || !isFinite(r.frameH)) return { ok: false };

      cropFrame.style.setProperty('display','block','important');
      cropFrame.style.setProperty('visibility','visible','important');
      cropFrame.style.setProperty('opacity','1','important');
      cropFrame.style.setProperty('z-index','2147483647','important');
      cropFrame.style.setProperty('border','3px solid orange','important');
      cropFrame.style.setProperty('box-shadow','0 0 0 9999px rgba(0,0,0,0.25)','important');

      detachCropFrameToBody();
      cropFrame.style.setProperty('position','fixed','important');
      cropFrame.style.setProperty('left', Math.round(r.left) + 'px','important');
      cropFrame.style.setProperty('top', Math.round(r.top) + 'px','important');
      cropFrame.style.setProperty('width', Math.round(r.frameW) + 'px','important');
      cropFrame.style.setProperty('height', Math.round(r.frameH) + 'px','important');
      cropFrame.style.setProperty('transform','none','important');

      return { ok: true, rect: r };
    }

    function ensureCropVisible() {
      const rect = cropFrame.getBoundingClientRect();
      const cs = window.getComputedStyle(cropFrame);
      if (cs.display === 'none' || rect.width === 0 || rect.height === 0) {
        cropFrame.style.setProperty('position','fixed','important');
        cropFrame.style.setProperty('left','50%','important');
        cropFrame.style.setProperty('top','50%','important');
        cropFrame.style.setProperty('transform','translate(-50%,-50%)','important');
        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        const margin = 0.85; const ratio = 15/10;
        let fw, fh;
        if (vw/vh > ratio) { fh = vh*margin; fw = fh*ratio; } else { fw = vw*margin; fh = fw/ratio; }
        cropFrame.style.setProperty('width', Math.round(fw)+'px','important');
        cropFrame.style.setProperty('height', Math.round(fh)+'px','important');
        cropFrame.style.setProperty('z-index','2147483647','important');
      }
    }

    function showFrame() {
      frameVisible = true;
      cropFrame.style.setProperty('display','block','important');
      cropFrame.style.setProperty('visibility','visible','important');
      cropFrame.style.setProperty('opacity','1','important');
      requestAnimationFrame(() => {
        updateCropFrame();
        ensureCropVisible();
      });
      btnFrame.textContent = 'Ukryj ramkę 10x15 cm';
    }

    function hideFrame() {
      frameVisible = false;
      reattachCropFrameToContainer();
      cropFrame.style.setProperty('display','none','important');
      btnFrame.textContent = 'Pokaż ramkę 10x15 cm';
    }

    btnFrame.addEventListener('click', () => { if (frameVisible) hideFrame(); else showFrame(); });
    map.on('move zoom', () => { if (frameVisible) updateCropFrame(); });
    window.addEventListener('resize', () => { if (frameVisible) updateCropFrame(); });

    // --- SVG highlight (multi) ---
    const MAX_BUILDINGS = 6;
    let buildingRings = [];

    function clearHighlight() {
      buildingRings = [];
      while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
    }
    function hexToRgba(hex, alpha = 0.35) {
      const c = hex.replace('#','');
      const bigint = parseInt(c, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }
    function getActiveColor() {
      return (activeColorPicker && activeColorPicker.value) || '#b36b00';
    }

    function updateHighlightSvg() {
      while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
      if (!buildingRings.length) return;

      const color = getActiveColor();
      const fill = hexToRgba(color, 0.35);
      const stroke = color;

      for (const ring of buildingRings) {
        if (!ring || ring.length < 3) continue;
        const pts = ring.map(([la, lo]) => {
          const p = map.latLngToContainerPoint([la, lo]);
          return `${p.x},${p.y}`;
        }).join(' ');
        const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute('points', pts);
        poly.setAttribute('fill', fill);
        poly.setAttribute('stroke', stroke);
        poly.setAttribute('stroke-width', '3');
        highlightSvg.appendChild(poly);
      }
    }
    map.on('move zoom', updateHighlightSvg);

    // --- pomocnicza funkcja: przybliżone pole wielokąta ---
    function polygonAreaApprox(coords) {
      let area = 0;
      for (let i = 0; i < coords.length; i++) {
        const [y1, x1] = coords[i];
        const [y2, x2] = coords[(i + 1) % coords.length];
        area += x1 * y2 - x2 * y1;
      }
      return Math.abs(area) / 2;
    }

    // --- Geocoding + Overpass + precyzyjne filtrowanie ---
    async function geocode(address) {
      const url = 'https://nominatim.openstreetmap.org/search?' +
        new URLSearchParams({ format:'json', limit:'1', q: address, polygon_geojson: 1 });
      const resp = await fetch(url, { headers: { 'Accept-Language': 'pl' } });
      if (!resp.ok) throw new Error('Błąd geokodowania');
      const data = await resp.json();
      if (!data.length) return null;
      return [parseFloat(data[0].lat), parseFloat(data[0].lon), data[0]];
    }

    async function fetchBuildingWays(lat, lon, radius = 60) {
      const query = `
[out:json][timeout:25];
(
  way["building"](around:${radius},${lat},${lon});
  relation["building"](around:${radius},${lat},${lon});
);
(._;>;);
out body;
`;
      const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
      if (!resp.ok) throw new Error('Błąd Overpass');
      const data = await resp.json();
      return data.elements || [];
    }

    function normalize(s='') {
      return String(s).trim().toLowerCase()
        .replace(/\./g,'')
        .replace(/\b(ulica|ul|al|aleja|al\.)\b/g,'')
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ').trim();
    }
    function pointInRing(lon, lat, ring) {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][1], yi = ring[i][0];
        const xj = ring[j][1], yj = ring[j][0];
        const intersect = ((yi > lat) !== (yj > lat)) &&
          (lon < (xj - xi) * (lat - yi) / (yj - yi + 0.0) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    let lastRequestId = 0;
    async function showBuildingsForAddresses() {
      const raw = adresInput.value.trim();
      if (!raw) { setStatus('Podaj adresy.', true); return; }

      setStatus('Szukam…');
      clearHighlight();
      const myId = ++lastRequestId;

            // Rozbij wpis, np. "Lodowa 54, 56, 60"
      const segments = raw.split(',').map(s => s.trim()).filter(Boolean);

      const addresses = [];
      let lastStreet = null;
      const lettersRegex = /[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż]/;
      const streetRegex = /^(.+?)\s+\d/;   // wszystko przed pierwszym numerem traktujemy jako nazwę ulicy

      for (const seg of segments) {
        const part = seg;

        if (lettersRegex.test(part) && /\d/.test(part)) {
          // Pełny adres z ulicą i numerem – zapamiętujemy ulicę
          const m = part.match(streetRegex);
          if (m) lastStreet = m[1].trim();
          addresses.push(part);
        } else if (lastStreet && /\d/.test(part) && !lettersRegex.test(part)) {
          // Sam numer (np. "56") – dokładamy ostatnią ulicę ("Lodowa 56")
          addresses.push(`${lastStreet} ${part}`);
        } else {
          // Nie rozpoznano – zostawiamy jak jest
          addresses.push(part);
        }
      }

      // Dodaj "Łódź," jeśli nie ma miasta
      const finalAddresses = addresses
        .slice(0, MAX_BUILDINGS)
        .map(a => {
          const lower = a.toLowerCase();
          if (!lower.includes('łódź') && !lower.includes('lodz')) return 'Łódź, ' + a;
          return a;
        });

      const allPoints = [];
      let foundCount = 0;

      // Dalej używamy finalAddresses zamiast addresses
      for (const addr of finalAddresses) {
        try {
          const geo = await geocode(addr);
          if (!geo) { continue; }
          const center = [geo[0], geo[1]];
          const nomiObj = geo[2];
          if (myId !== lastRequestId) return;

          // --- Nominatim: polygon tylko gdy NIE jest to Bartoka 1 ---
          let usedFromNominatim = false;
          if (nomiObj && nomiObj.geojson && !/bartoka\s+1\b/i.test(addr)) {
            const g = nomiObj.geojson;
            if (g.type === 'Polygon') {
              const ring = g.coordinates[0].map(([lon, lat]) => [lat, lon]);
              buildingRings.push(ring);
              allPoints.push(...ring);
              foundCount++;
              usedFromNominatim = true;
            } else if (g.type === 'MultiPolygon') {
              for (const poly of g.coordinates) {
                const ring = poly[0].map(([lon, lat]) => [lat, lon]);
                buildingRings.push(ring);
                allPoints.push(...ring);
                foundCount++;
              }
              usedFromNominatim = true;
            }
            if (usedFromNominatim) {
              if (myId !== lastRequestId) return;
              continue; // mamy polygon budynku, nie trzeba Overpass
            }
          }

          // --- Overpass ---
          const elems = await fetchBuildingWays(center[0], center[1], 60);
          if (myId !== lastRequestId) return;
          if (!elems.length) { continue; }

          const nodeMap = new Map();
          for (const el of elems) if (el.type === 'node') nodeMap.set(el.id, [el.lat, el.lon]);

          const rings = [];
          const ways = elems.filter(el => el.type === 'way');
          for (const w of ways) {
            const coords = w.nodes.map(id => nodeMap.get(id)).filter(Boolean);
            if (coords.length >= 3) {
              rings.push({
                coords,
                tags: w.tags || {},
                area: polygonAreaApprox(coords)
              });
            }
          }

          const relations = elems.filter(el => el.type === 'relation' && el.tags && (el.tags.type === 'multipolygon' || el.tags.building));
          for (const rel of relations) {
            if (!rel.members) continue;
            const outerMembers = rel.members.filter(m => m.type === 'way' && (m.role === 'outer' || m.role === ''));
            for (const m of outerMembers) {
              const way = elems.find(e => e.type === 'way' && e.id === m.ref);
              if (!way) continue;
              const coords = way.nodes.map(id => nodeMap.get(id)).filter(Boolean);
              if (coords.length >= 3) {
                rings.push({
                  coords,
                  tags: way.tags || {},
                  area: polygonAreaApprox(coords)
                });
              }
            }
          }

          if (rings.length === 0) { continue; }

          // parsowanie adresu: ulica + numer
          const m = addr.match(/(.*)\s+(\d+[a-zA-Z0-9\-\/]*)$/);
          const wanted = {};
          if (m) { wanted.street = normalize(m[1]); wanted.number = normalize(m[2]); }

          // filtrujemy: dokładny addr:* lub point-in-polygon
          const matches = [];
          for (const r of rings) {
            const tags = r.tags || {};
            let accept = false;
            if (tags['addr:housenumber'] || tags['addr:street']) {
              const tagNum = normalize(tags['addr:housenumber'] || '');
              const tagStreet = normalize(tags['addr:street'] || tags['addr:street:name'] || '');
              if (wanted.number && wanted.street && tagNum === wanted.number && tagStreet === wanted.street) {
                accept = true;
              }
            }
            if (!accept) {
              if (pointInRing(center[1], center[0], r.coords)) accept = true;
            }
            if (accept) matches.push(r);
          }

          // wybór finalnych budynków
          let finalPicked = [];

          if (matches.length) {
            // SPECJALNY przypadek: Bartoka 1 – wybierz największy z DOPASOWANYCH
            if (wanted.street === 'bartoka' && wanted.number === '1') {
              let largest = matches[0];
              for (const r of matches) {
                if (r.area > largest.area) largest = r;
              }
              finalPicked = [largest.coords];
            } else {
              finalPicked = matches.map(r => r.coords);
            }
          } else {
            // fallback: najbliższy budynek
            const wayInfos = rings.map(rr => {
              const coords = rr.coords;
              let sumLat=0,sumLon=0;
              for (const [la,lo] of coords){ sumLat+=la; sumLon+=lo; }
              const cLat = sumLat/coords.length, cLon = sumLon/coords.length;
              const dLat = cLat - center[0], dLon = cLon - center[1];
              return { coords, dist2: dLat*dLat + dLon*dLon };
            }).sort((a,b)=>a.dist2-b.dist2);
            if (wayInfos.length) finalPicked.push(wayInfos[0].coords);
          }

          for (const p of finalPicked) {
            if (buildingRings.length >= MAX_BUILDINGS) break;
            buildingRings.push(p);
            allPoints.push(...p);
            foundCount++;
          }

        } catch (err) {
          // cicho obsługujemy błędy
        }
      }

      if (buildingRings.length) {
        updateHighlightSvg();
        const tmpPoly = L.polygon([].concat(...buildingRings));
        map.fitBounds(tmpPoly.getBounds().pad(0.6));
        setStatus(`Zaznaczono ${buildingRings.length} budynków (${addresses.length} adresów).`);
      } else {
        setStatus('Nie znaleziono precyzyjnych dopasowań dla podanych adresów.', true);
      }
    }

    btnShow.addEventListener('click', async () => {
      clearHighlight();
      await showBuildingsForAddresses();
    });
    adresInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        clearHighlight();
        showBuildingsForAddresses();
      }
    });

    // --- Eksport PNG 10x15 cm @300 DPI ---
    const HTML2CANVAS_SCALE = 3;
    async function saveFramePng() {
      if (!frameVisible) { setStatus('Najpierw włącz ramkę kopiowania.', true); return; }
      try {
        setStatus('Generuję obraz wysokiej rozdzielczości…');
        const fullCanvas = await html2canvas(mapContainer, { useCORS: true, logging: false, scale: HTML2CANVAS_SCALE });

        const frameRect = cropFrame.getBoundingClientRect();
        const contRect = mapContainer.getBoundingClientRect();

        const sx = frameRect.left - contRect.left;
        const sy = frameRect.top  - contRect.top;
        const sw = frameRect.width;
        const sh = frameRect.height;

        const scaleX = fullCanvas.width  / mapContainer.clientWidth;
        const scaleY = fullCanvas.height / mapContainer.clientHeight;

        const sxScaled = sx * scaleX;
        const syScaled = sy * scaleY;
        const swScaled = sw * scaleX;
        const shScaled = sh * scaleY;

        const outCanvas = document.createElement('canvas');
        outCanvas.width = TARGET_WIDTH_PX;
        outCanvas.height = TARGET_HEIGHT_PX;
        const ctx = outCanvas.getContext('2d');

        ctx.drawImage(fullCanvas, sxScaled, syScaled, swScaled, shScaled, 0, 0, TARGET_WIDTH_PX, TARGET_HEIGHT_PX);

        const dataUrl = outCanvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;

        let baseName = (filenameInput.value || 'map_10x15cm_300dpi').trim();
        if (!baseName.toLowerCase().endsWith('.png')) baseName += '.png';
        a.download = baseName;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        setStatus('Zapisano PNG.');
      } catch (err) {
        setStatus('Błąd tworzenia PNG. Użyj ręcznego zrzutu jako fallback.', true);
      }
    }
    btnSave.addEventListener('click', saveFramePng);

    function handleColorInput(e) {
      activeColorPicker = e.target;
      updateHighlightSvg();
    }

    colorPicker1.addEventListener('input', handleColorInput);
    colorPicker2.addEventListener('input', handleColorInput);

    colorPicker1.addEventListener('click', () => { activeColorPicker = colorPicker1; updateHighlightSvg(); });
    colorPicker2.addEventListener('click', () => { activeColorPicker = colorPicker2; updateHighlightSvg(); });

  </script>
</body>
</html>
