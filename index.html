<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Podświetlone budynki – final (precyzyjne dopasowanie)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin:0; padding:0; }
    header { padding:10px; background:#222; color:#f5f5f5; }
    #controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .flex-break { flex-basis: 100%; height: 0; }

    #adres { min-width:320px; padding:4px 8px; }
    #filename { min-width:220px; padding:4px 8px; }
    #status { margin-top:6px; font-size:0.9em; color:#d0ffd0; }
    #map-container { position:relative; height:calc(100vh - 120px); width:100%; overflow:hidden; }
    #map { height:100%; width:100%; }

    #crop-frame {
      position: absolute;
      display: none;
      pointer-events: none;
      border: 3px solid rgba(255,165,0,0.85);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.15);
      background: transparent;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 100000;
    }

    #highlight-svg {
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:none; z-index:900;
    }

    button { padding:6px 10px; cursor:pointer; }
    input[type="color"] { width:36px; height:28px; padding:0; border:0; background:transparent; cursor:pointer; }
    label.inline { display:inline-flex; align-items:center; gap:6px; }
  </style>
</head>
<body>
  <header>
    <div id="controls">
      <span>Adresy (oddzielone przecinkami):</span>
      <input id="adres" type="text" value="" />

      <label class="inline">Kolor 1:
        <input id="color-picker-1" type="color" value="#e73eea" />
      </label>

      <label class="inline">Kolor 2:
        <input id="color-picker-2" type="color" value="#0666e5" />
      </label>

      <label class="inline">
        <input id="chk-streets" type="checkbox" checked />
        Zaznacz ulice na czerwono
      </label>

      <label class="inline">Nazwa pliku:
        <input id="filename" type="text" value="Teren_nr_" />
      </label>

      <div class="flex-break"></div>

      <button id="btn-show">Pokaż budynki</button>
      <button id="btn-frame">Pokaż ramkę 10x15 cm</button>
      <button id="btn-save">Zapisz PNG (300 DPI)</button>
    </div>
    <div id="status"></div>
  </header>

  <div id="map-container">
    <div id="map"></div>
    <svg id="highlight-svg" aria-hidden="true"></svg>
    <div id="crop-frame"></div>
  </div>

  <script>
    // =========================================================
    //  STAŁY ZOOM – ustaw tutaj:
    // =========================================================
    const FIXED_ZOOM = 17;    // <- wpisz swój zoom (np. 17, 18, 19...)
    const LOCK_ZOOM  = false; // <- true = użytkownik nie zmieni zoomu ręcznie
    // =========================================================

    // --- Inicjalizacja mapy ---
    const map = L.map('map', {
      minZoom: LOCK_ZOOM ? FIXED_ZOOM : 0,
      maxZoom: LOCK_ZOOM ? FIXED_ZOOM : 20
    }).setView([51.759, 19.456], FIXED_ZOOM);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20,
      attribution: '© OpenStreetMap',
      crossOrigin: true
    }).addTo(map);

    // Warstwa na czerwone ulice
    const streetLayer = L.layerGroup().addTo(map);

    // DOM
    const adresInput = document.getElementById('adres');
    const btnShow = document.getElementById('btn-show');
    const btnFrame = document.getElementById('btn-frame');
    const btnSave = document.getElementById('btn-save');
    const colorPicker1 = document.getElementById('color-picker-1');
    const colorPicker2 = document.getElementById('color-picker-2');
    const chkStreets = document.getElementById('chk-streets');
    let activeColorPicker = colorPicker1; // domyślnie Kolor 1
    const filenameInput = document.getElementById('filename');
    const statusEl = document.getElementById('status');
    const mapContainer = document.getElementById('map-container');
    const cropFrame = document.getElementById('crop-frame');
    const highlightSvg = document.getElementById('highlight-svg');

    function setStatus(text, isError = false) {
      statusEl.textContent = text;
      statusEl.style.color = isError ? '#ff8080' : '#d0ffd0';
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- Wymiary 10x15 cm @300dpi ---
    const DPI = 300;
    const CM_TO_INCH = 1/2.54;
    const TARGET_WIDTH_CM = 15;
    const TARGET_HEIGHT_CM = 10;
    const TARGET_WIDTH_PX = Math.round(TARGET_WIDTH_CM * CM_TO_INCH * DPI);
    const TARGET_HEIGHT_PX = Math.round(TARGET_HEIGHT_CM * CM_TO_INCH * DPI);
    const ratioWidth = TARGET_WIDTH_CM;
    const ratioHeight = TARGET_HEIGHT_CM;

    // --- Ramka: detach + pozycjonowanie ---
    let frameVisible = false;
    let cropFrameIsDetached = false;
    let cropFramePrevStyles = null;

    function computeFrameRectForContainer(containerRect) {
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      const targetRatio = ratioWidth / ratioHeight;
      const margin = 0.85;
      const w = containerRect.width;
      const h = containerRect.height;
      let frameW, frameH;
      if (w && h) {
        if (w / h > targetRatio) {
          frameH = h * margin;
          frameW = frameH * targetRatio;
        } else {
          frameW = w * margin;
          frameH = frameW / targetRatio;
        }
      } else {
        if (vw / vh > targetRatio) {
          frameH = vh * margin;
          frameW = frameH * targetRatio;
        } else {
          frameW = vw * margin;
          frameH = frameW / targetRatio;
        }
      }
      const left = containerRect.left + (containerRect.width - frameW) / 2;
      const top  = containerRect.top  + (containerRect.height - frameH) / 2;
      return { frameW, frameH, left, top };
    }

    function detachCropFrameToBody() {
      if (cropFrameIsDetached) return;
      cropFramePrevStyles = {
        position: cropFrame.style.position || '',
        left: cropFrame.style.left || '',
        top: cropFrame.style.top || '',
        transform: cropFrame.style.transform || '',
        width: cropFrame.style.width || '',
        height: cropFrame.style.height || '',
        zIndex: cropFrame.style.zIndex || '',
        display: cropFrame.style.display || ''
      };
      document.body.appendChild(cropFrame);
      cropFrameIsDetached = true;
    }

    function reattachCropFrameToContainer() {
      if (!cropFrameIsDetached) return;
      mapContainer.appendChild(cropFrame);
      if (cropFramePrevStyles) {
        cropFrame.style.position = cropFramePrevStyles.position;
        cropFrame.style.left = cropFramePrevStyles.left;
        cropFrame.style.top = cropFramePrevStyles.top;
        cropFrame.style.transform = cropFramePrevStyles.transform;
        cropFrame.style.width = cropFramePrevStyles.width;
        cropFrame.style.height = cropFramePrevStyles.height;
        cropFrame.style.zIndex = cropFramePrevStyles.zIndex;
        cropFrame.style.display = cropFramePrevStyles.display;
      }
      cropFrameIsDetached = false;
      cropFramePrevStyles = null;
    }

    function updateCropFrame() {
      if (!frameVisible) return { ok: false };
      const contRect = mapContainer.getBoundingClientRect();
      const r = computeFrameRectForContainer(contRect);
      if (!r || !isFinite(r.frameW) || !isFinite(r.frameH)) return { ok: false };

      cropFrame.style.setProperty('display','block','important');
      cropFrame.style.setProperty('visibility','visible','important');
      cropFrame.style.setProperty('opacity','1','important');
      cropFrame.style.setProperty('z-index','2147483647','important');
      cropFrame.style.setProperty('border','3px solid orange','important');
      cropFrame.style.setProperty('box-shadow','0 0 0 9999px rgba(0,0,0,0.25)','important');

      detachCropFrameToBody();
      cropFrame.style.setProperty('position','fixed','important');
      cropFrame.style.setProperty('left', Math.round(r.left) + 'px','important');
      cropFrame.style.setProperty('top', Math.round(r.top) + 'px','important');
      cropFrame.style.setProperty('width', Math.round(r.frameW) + 'px','important');
      cropFrame.style.setProperty('height', Math.round(r.frameH) + 'px','important');
      cropFrame.style.setProperty('transform','none','important');

      return { ok: true, rect: r };
    }

    function ensureCropVisible() {
      const rect = cropFrame.getBoundingClientRect();
      const cs = window.getComputedStyle(cropFrame);
      if (cs.display === 'none' || rect.width === 0 || rect.height === 0) {
        cropFrame.style.setProperty('position','fixed','important');
        cropFrame.style.setProperty('left','50%','important');
        cropFrame.style.setProperty('top','50%','important');
        cropFrame.style.setProperty('transform','translate(-50%,-50%)','important');
        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        const margin = 0.85; const ratio = 15/10;
        let fw, fh;
        if (vw/vh > ratio) { fh = vh*margin; fw = fh*ratio; } else { fw = vw*margin; fh = fw/ratio; }
        cropFrame.style.setProperty('width', Math.round(fw)+'px','important');
        cropFrame.style.setProperty('height', Math.round(fh)+'px','important');
        cropFrame.style.setProperty('z-index','2147483647','important');
      }
    }

    function showFrame() {
      frameVisible = true;
      cropFrame.style.setProperty('display','block','important');
      cropFrame.style.setProperty('visibility','visible','important');
      cropFrame.style.setProperty('opacity','1','important');
      requestAnimationFrame(() => {
        updateCropFrame();
        ensureCropVisible();
      });
      btnFrame.textContent = 'Ukryj ramkę 10x15 cm';
    }

    function hideFrame() {
      frameVisible = false;
      reattachCropFrameToContainer();
      cropFrame.style.setProperty('display','none','important');
      btnFrame.textContent = 'Pokaż ramkę 10x15 cm';
    }

    btnFrame.addEventListener('click', () => { if (frameVisible) hideFrame(); else showFrame(); });
    map.on('move zoom', () => { if (frameVisible) updateCropFrame(); });
    window.addEventListener('resize', () => { if (frameVisible) updateCropFrame(); });

    // --- SVG highlight (multi) ---
    const MAX_BUILDINGS = Infinity; // bez limitu
    let buildingRings = [];

    function clearHighlight() {
      buildingRings = [];
      while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
    }

    function clearStreets() {
      streetLayer.clearLayers();
    }

    function hexToRgba(hex, alpha = 0.35) {
      const c = hex.replace('#','');
      const bigint = parseInt(c, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }
    function getActiveColor() {
      return (activeColorPicker && activeColorPicker.value) || '#b36b00';
    }

    function updateHighlightSvg() {
      while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
      if (!buildingRings.length) return;

      const color = getActiveColor();
      const fill = hexToRgba(color, 0.35);
      const stroke = color;

      for (const ring of buildingRings) {
        if (!ring || ring.length < 3) continue;
        const pts = ring.map(([la, lo]) => {
          const p = map.latLngToContainerPoint([la, lo]);
          return `${p.x},${p.y}`;
        }).join(' ');
        const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute('points', pts);
        poly.setAttribute('fill', fill);
        poly.setAttribute('stroke', stroke);
        poly.setAttribute('stroke-width', '3');
        highlightSvg.appendChild(poly);
      }
    }
    map.on('move zoom', updateHighlightSvg);

    // --- pomocnicza funkcja: przybliżone pole wielokąta ---
    function polygonAreaApprox(coords) {
      let area = 0;
      for (let i = 0; i < coords.length; i++) {
        const [y1, x1] = coords[i];
        const [y2, x2] = coords[(i + 1) % coords.length];
        area += x1 * y2 - x2 * y1;
      }
      return Math.abs(area) / 2;
    }

    // --- Geocoding + Overpass + precyzyjne filtrowanie ---
    async function geocode(address) {
      const url = 'https://nominatim.openstreetmap.org/search?' +
        new URLSearchParams({ format:'json', limit:'1', q: address, polygon_geojson: 1 });
      const resp = await fetch(url, { headers: { 'Accept-Language': 'pl' } });
      if (!resp.ok) throw new Error('Błąd geokodowania');
      const data = await resp.json();
      if (!data.length) return null;
      return [parseFloat(data[0].lat), parseFloat(data[0].lon), data[0]];
    }

    async function fetchBuildingWays(lat, lon, radius = 60) {
      const query = `
[out:json][timeout:25];
(
  way["building"](around:${radius},${lat},${lon});
  relation["building"](around:${radius},${lat},${lon});
);
(._;>;);
out body;
`;
      const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
      if (!resp.ok) throw new Error('Błąd Overpass');
      const data = await resp.json();
      return data.elements || [];
    }

    function normalize(s='') {
      return String(s).trim().toLowerCase()
        .replace(/\./g,'')
        .replace(/\b(ulica|ul|al|aleja|al\.)\b/g,'')
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ').trim();
    }

    function pointInRing(lon, lat, ring) {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][1], yi = ring[i][0];
        const xj = ring[j][1], yj = ring[j][0];
        const intersect = ((yi > lat) !== (yj > lat)) &&
          (lon < (xj - xi) * (lat - yi) / (yj - yi + 0.0) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // "Ulica 123" -> wyciągnij "Ulica"
    function extractStreet(s) {
      const m = String(s).trim().match(/^(.+?)\s+\d/);
      return m ? m[1].trim() : null;
    }

    // ===== Ulice: tylko okolica budynków (bbox) =====
    function opEscape(s) {
      return String(s).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    async function fetchStreetWaysByBBox(bbox, streetNames) {
      // bbox: { south, west, north, east }
      const { south, west, north, east } = bbox;

      const parts = streetNames.map(nm => {
        const nn = opEscape(nm);
        return `way["highway"]["name"="${nn}"](${south},${west},${north},${east});`;
      }).join('\n  ');

      const query = `
[out:json][timeout:25];
(
  ${parts}
);
out geom;
`;

      const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
      if (!resp.ok) throw new Error('Błąd Overpass (ulice)');
      const data = await resp.json();
      return data.elements || [];
    }

    function boundsToBboxObj(bounds) {
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();
      return { south: sw.lat, west: sw.lng, north: ne.lat, east: ne.lng };
    }

    // proste “przycinanie” linii do bbox: zostawiamy tylko odcinki, gdzie punkty są wewnątrz bounds
    function clipPolylineToBounds(points, bounds) {
      const segs = [];
      let cur = [];

      for (const p of points) {
        const ll = L.latLng(p[0], p[1]);
        if (bounds.contains(ll)) {
          cur.push([ll.lat, ll.lng]);
        } else {
          if (cur.length >= 2) segs.push(cur);
          cur = [];
        }
      }
      if (cur.length >= 2) segs.push(cur);
      return segs;
    }

    async function highlightStreetsNearBuildings(streetNames, focusBounds, myId) {
      clearStreets();
      if (!streetNames || !streetNames.length) return { ways: 0, segs: 0 };

      // trochę większa “strefa” do pobrania i rysowania
      const queryBounds = focusBounds.pad(0.35);  // pobranie
      const drawBounds  = focusBounds.pad(0.25);  // przycinanie

      const bbox = boundsToBboxObj(queryBounds);

      // batchowanie, bo Overpass nie lubi gigantycznych query
      const BATCH = 25;
      let totalWays = 0;
      let totalSegs = 0;

      for (let i = 0; i < streetNames.length; i += BATCH) {
        if (myId !== lastRequestId) return { ways: totalWays, segs: totalSegs };

        const batch = streetNames.slice(i, i + BATCH);
        try {
          const elems = await fetchStreetWaysByBBox(bbox, batch);
          if (myId !== lastRequestId) return { ways: totalWays, segs: totalSegs };

          const ways = elems.filter(e => e.type === 'way' && Array.isArray(e.geometry) && e.geometry.length >= 2);
          totalWays += ways.length;

          for (const w of ways) {
            const pts = w.geometry.map(p => [p.lat, p.lon]);

            // przytnij do obszaru, żeby nie rysować “ogonów”
            const segs = clipPolylineToBounds(pts, drawBounds);
            totalSegs += segs.length;

            for (const seg of segs) {
              L.polyline(seg, {
                color: '#ff0000',
                weight: 5,
                opacity: 0.9,
                lineCap: 'round',
                lineJoin: 'round'
              }).addTo(streetLayer);
            }
          }

        } catch (e) {
          // cicho
        }

        await sleep(250);
      }

      return { ways: totalWays, segs: totalSegs };
    }

    let lastRequestId = 0;

    async function showBuildingsForAddresses() {
      const raw = adresInput.value.trim();
      if (!raw) { setStatus('Podaj adresy.', true); return; }

      setStatus('Szukam…');
      clearHighlight();
      clearStreets();
      const myId = ++lastRequestId;

      // Rozbij wpis, np. "Listopadowa 111, 113, 115A/2, Piotrkowska 10, 12"
      const segments = raw.split(',').map(s => s.trim()).filter(Boolean);

      const addresses = [];
      let lastStreet = null;

      // sam numer domu (np. 113, 113A, 113/1, 113-115)
      const isHouseNumberOnly = (s) =>
        /^\d+[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż0-9\-\/]*$/.test(s);

      // czy wygląda na "ulica + numer"
      const looksLikeStreetAndNumber = (s) =>
        /[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż]/.test(s) && /\d/.test(s) && !!extractStreet(s);

      for (const part of segments) {
        // 1) pełny wpis "ulica + numer" -> zapamiętaj ulicę
        if (looksLikeStreetAndNumber(part)) {
          const st = extractStreet(part);
          if (st) lastStreet = st;
          addresses.push(part);
          continue;
        }

        // 2) sam numer -> dopnij do ostatniej ulicy
        if (lastStreet && isHouseNumberOnly(part)) {
          addresses.push(`${lastStreet} ${part}`);
          continue;
        }

        // 3) cokolwiek innego -> zostaw jak jest (nie psuj lastStreet)
        addresses.push(part);
      }

      // Ulice do podświetlenia (unikalne)
      const streetSet = new Set();
      for (const a of addresses) {
        const st = extractStreet(a);
        if (st) streetSet.add(st.trim());
      }
      const streetsToHighlight = Array.from(streetSet);

      // Bez limitu adresów:
      const finalAddresses = addresses.map(a => {
        const lower = a.toLowerCase();
        if (!lower.includes('łódź') && !lower.includes('lodz')) return 'Łódź, ' + a;
        return a;
      });

      const allPoints = [];

      for (const addr of finalAddresses) {
        try {
          const geo = await geocode(addr);
          if (!geo) { continue; }
          const center = [geo[0], geo[1]];
          const nomiObj = geo[2];
          if (myId !== lastRequestId) return;

          // --- Nominatim: polygon tylko gdy NIE jest to Bartoka 1 ---
          let usedFromNominatim = false;
          if (nomiObj && nomiObj.geojson && !/bartoka\s+1\b/i.test(addr)) {
            const g = nomiObj.geojson;
            if (g.type === 'Polygon') {
              const ring = g.coordinates[0].map(([lon, lat]) => [lat, lon]);
              buildingRings.push(ring);
              allPoints.push(...ring);
              usedFromNominatim = true;
            } else if (g.type === 'MultiPolygon') {
              for (const poly of g.coordinates) {
                const ring = poly[0].map(([lon, lat]) => [lat, lon]);
                buildingRings.push(ring);
                allPoints.push(...ring);
              }
              usedFromNominatim = true;
            }
            if (usedFromNominatim) {
              if (myId !== lastRequestId) return;
              continue;
            }
          }

          // --- Overpass ---
          const elems = await fetchBuildingWays(center[0], center[1], 60);
          if (myId !== lastRequestId) return;
          if (!elems.length) { continue; }

          const nodeMap = new Map();
          for (const el of elems) if (el.type === 'node') nodeMap.set(el.id, [el.lat, el.lon]);

          const rings = [];
          const ways = elems.filter(el => el.type === 'way');
          for (const w of ways) {
            const coords = w.nodes.map(id => nodeMap.get(id)).filter(Boolean);
            if (coords.length >= 3) {
              rings.push({ coords, tags: w.tags || {}, area: polygonAreaApprox(coords) });
            }
          }

          const relations = elems.filter(el => el.type === 'relation' && el.tags && (el.tags.type === 'multipolygon' || el.tags.building));
          for (const rel of relations) {
            if (!rel.members) continue;
            const outerMembers = rel.members.filter(m => m.type === 'way' && (m.role === 'outer' || m.role === ''));
            for (const m of outerMembers) {
              const way = elems.find(e => e.type === 'way' && e.id === m.ref);
              if (!way) continue;
              const coords = way.nodes.map(id => nodeMap.get(id)).filter(Boolean);
              if (coords.length >= 3) {
                rings.push({ coords, tags: way.tags || {}, area: polygonAreaApprox(coords) });
              }
            }
          }

          if (rings.length === 0) { continue; }

          const m = addr.match(/(.*)\s+(\d+[a-zA-Z0-9\-\/]*)$/);
          const wanted = {};
          if (m) { wanted.street = normalize(m[1]); wanted.number = normalize(m[2]); }

          const matches = [];
          for (const r of rings) {
            const tags = r.tags || {};
            let accept = false;

            if (tags['addr:housenumber'] || tags['addr:street']) {
              const tagNum = normalize(tags['addr:housenumber'] || '');
              const tagStreet = normalize(tags['addr:street'] || tags['addr:street:name'] || '');
              if (wanted.number && wanted.street && tagNum === wanted.number && tagStreet === wanted.street) {
                accept = true;
              }
            }
            if (!accept) {
              if (pointInRing(center[1], center[0], r.coords)) accept = true;
            }
            if (accept) matches.push(r);
          }

          let finalPicked = [];

          if (matches.length) {
            if (wanted.street === 'bartoka' && wanted.number === '1') {
              let largest = matches[0];
              for (const r of matches) if (r.area > largest.area) largest = r;
              finalPicked = [largest.coords];
            } else {
              finalPicked = matches.map(r => r.coords);
            }
          } else {
            const wayInfos = rings.map(rr => {
              const coords = rr.coords;
              let sumLat=0,sumLon=0;
              for (const [la,lo] of coords){ sumLat+=la; sumLon+=lo; }
              const cLat = sumLat/coords.length, cLon = sumLon/coords.length;
              const dLat = cLat - center[0], dLon = cLon - center[1];
              return { coords, dist2: dLat*dLat + dLon*dLon };
            }).sort((a,b)=>a.dist2-b.dist2);
            if (wayInfos.length) finalPicked.push(wayInfos[0].coords);
          }

          for (const p of finalPicked) {
            buildingRings.push(p);
            allPoints.push(...p);
          }

        } catch (err) {
          // cicho
        }
      }

      if (!buildingRings.length) {
        setStatus('Nie znaleziono precyzyjnych dopasowań dla podanych adresów.', true);
        return;
      }

      // Rysuj budynki
      updateHighlightSvg();

      // Stały zoom, tylko centrowanie
      const tmpPoly = L.polygon([].concat(...buildingRings));
      const focusBounds = tmpPoly.getBounds();
      map.setView(focusBounds.getCenter(), FIXED_ZOOM, { animate: true });

      // Ulice (czerwona kreska) – tylko okolica budynków
      if (chkStreets.checked && streetsToHighlight.length) {
        setStatus(`Zaznaczono ${buildingRings.length} budynków (${addresses.length} adresów). Rysuję ulice w okolicy…`);
        const r = await highlightStreetsNearBuildings(streetsToHighlight, focusBounds, myId);
        if (myId !== lastRequestId) return;
        setStatus(`Zaznaczono ${buildingRings.length} budynków (${addresses.length} adresów). Ulice: ${streetsToHighlight.length} (ways: ${r.ways}, odcinki: ${r.segs}).`);
      } else {
        setStatus(`Zaznaczono ${buildingRings.length} budynków (${addresses.length} adresów).`);
      }
    }

    btnShow.addEventListener('click', async () => {
      clearHighlight();
      clearStreets();
      await showBuildingsForAddresses();
    });

    adresInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        clearHighlight();
        clearStreets();
        showBuildingsForAddresses();
      }
    });

    // --- Eksport PNG 10x15 cm @300 DPI ---
    const HTML2CANVAS_SCALE = 3;

    async function saveFramePng() {
      if (!frameVisible) { setStatus('Najpierw włącz ramkę kopiowania.', true); return; }
      try {
        setStatus('Generuję obraz wysokiej rozdzielczości…');
        const fullCanvas = await html2canvas(mapContainer, { useCORS: true, logging: false, scale: HTML2CANVAS_SCALE });

        const frameRect = cropFrame.getBoundingClientRect();
        const contRect = mapContainer.getBoundingClientRect();

        const sx = frameRect.left - contRect.left;
        const sy = frameRect.top  - contRect.top;
        const sw = frameRect.width;
        const sh = frameRect.height;

        const scaleX = fullCanvas.width  / mapContainer.clientWidth;
        const scaleY = fullCanvas.height / mapContainer.clientHeight;

        const sxScaled = sx * scaleX;
        const syScaled = sy * scaleY;
        const swScaled = sw * scaleX;
        const shScaled = sh * scaleY;

        const outCanvas = document.createElement('canvas');
        outCanvas.width = TARGET_WIDTH_PX;
        outCanvas.height = TARGET_HEIGHT_PX;
        const ctx = outCanvas.getContext('2d');

        ctx.drawImage(fullCanvas, sxScaled, syScaled, swScaled, shScaled, 0, 0, TARGET_WIDTH_PX, TARGET_HEIGHT_PX);

        const dataUrl = outCanvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;

        let baseName = (filenameInput.value || 'map_10x15cm_300dpi').trim();
        if (!baseName.toLowerCase().endsWith('.png')) baseName += '.png';
        a.download = baseName;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        setStatus('Zapisano PNG.');
      } catch (err) {
        setStatus('Błąd tworzenia PNG. Użyj ręcznego zrzutu jako fallback.', true);
      }
    }

    btnSave.addEventListener('click', saveFramePng);

    function handleColorInput(e) {
      activeColorPicker = e.target;
      updateHighlightSvg();
    }

    colorPicker1.addEventListener('input', handleColorInput);
    colorPicker2.addEventListener('input', handleColorInput);

    colorPicker1.addEventListener('click', () => { activeColorPicker = colorPicker1; updateHighlightSvg(); });
    colorPicker2.addEventListener('click', () => { activeColorPicker = colorPicker2; updateHighlightSvg(); });

  </script>
</body>
</html>
