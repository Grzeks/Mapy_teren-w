<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Podświetlone budynki + ulice (zakres)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin:0; padding:0; }
    header { padding:10px; background:#222; color:#f5f5f5; }
    #controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .flex-break { flex-basis: 100%; height: 0; }

    #adres { min-width:320px; padding:4px 8px; }
    #ulice { min-width:420px; padding:4px 8px; }
    #filename { min-width:220px; padding:4px 8px; }

    #status { margin-top:6px; font-size:0.9em; color:#d0ffd0; }
    #map-container { position:relative; height:calc(100vh - 140px); width:100%; overflow:hidden; }
    #map { height:100%; width:100%; }

    #crop-frame {
      position: absolute;
      display: none;
      pointer-events: none;
      border: 3px solid rgba(255,165,0,0.85);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.15);
      background: transparent;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 100000;
    }

    #highlight-svg {
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:none; z-index:900;
    }

    button { padding:6px 10px; cursor:pointer; }
    input[type="color"] { width:36px; height:28px; padding:0; border:0; background:transparent; cursor:pointer; }
    label.inline { display:inline-flex; align-items:center; gap:6px; }
  </style>
</head>
<body>
  <header>
    <div id="controls">
      <span>Adresy (budynki, przecinki):</span>
      <input id="adres" type="text" value="" placeholder="np. Listopadowa 111, 113, 115A/2" />

      <label class="inline">Kolor 1:
        <input id="color-picker-1" type="color" value="#e73eea" />
      </label>

      <label class="inline">Kolor 2:
        <input id="color-picker-2" type="color" value="#0666e5" />
      </label>

      <div class="flex-break"></div>

      <span>Ulice (zakresy, przecinki):</span>
      <input id="ulice" type="text" value="" placeholder="np. Piotrkowska 10-20, Listopadowa 111-125A" />
      <button id="btn-streets">Pokaż ulice (zakres)</button>

      <label class="inline">
        <input id="chk-streets" type="checkbox" checked />
        Pokazuj ulice na czerwono
      </label>

      <div class="flex-break"></div>

      <label class="inline">Nazwa pliku:
        <input id="filename" type="text" value="Teren_nr_" />
      </label>

      <button id="btn-show">Pokaż budynki</button>
      <button id="btn-frame">Pokaż ramkę 10x15 cm</button>
      <button id="btn-save">Zapisz PNG (300 DPI)</button>
    </div>
    <div id="status"></div>
  </header>

  <div id="map-container">
    <div id="map"></div>
    <svg id="highlight-svg" aria-hidden="true"></svg>
    <div id="crop-frame"></div>
  </div>

  <script>
    // =========================================================
    //  STAŁY ZOOM – ustaw tutaj:
    // =========================================================
    const FIXED_ZOOM = 17;
    const LOCK_ZOOM  = false;
    // =========================================================

    // --- Inicjalizacja mapy ---
    const map = L.map('map', {
      minZoom: LOCK_ZOOM ? FIXED_ZOOM : 0,
      maxZoom: LOCK_ZOOM ? FIXED_ZOOM : 20
    }).setView([51.759, 19.456], FIXED_ZOOM);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20,
      attribution: '© OpenStreetMap',
      crossOrigin: true
    }).addTo(map);

    // Warstwa na czerwone ulice
    const streetLayer = L.layerGroup().addTo(map);

    // DOM
    const adresInput = document.getElementById('adres');
    const uliceInput = document.getElementById('ulice');
    const btnShow = document.getElementById('btn-show');
    const btnStreets = document.getElementById('btn-streets');
    const btnFrame = document.getElementById('btn-frame');
    const btnSave = document.getElementById('btn-save');
    const colorPicker1 = document.getElementById('color-picker-1');
    const colorPicker2 = document.getElementById('color-picker-2');
    const chkStreets = document.getElementById('chk-streets');
    let activeColorPicker = colorPicker1;
    const filenameInput = document.getElementById('filename');
    const statusEl = document.getElementById('status');
    const mapContainer = document.getElementById('map-container');
    const cropFrame = document.getElementById('crop-frame');
    const highlightSvg = document.getElementById('highlight-svg');

    function setStatus(text, isError = false) {
      statusEl.textContent = text;
      statusEl.style.color = isError ? '#ff8080' : '#d0ffd0';
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- Wymiary 10x15 cm @300dpi ---
    const DPI = 300;
    const CM_TO_INCH = 1/2.54;
    const TARGET_WIDTH_CM = 15;
    const TARGET_HEIGHT_CM = 10;
    const TARGET_WIDTH_PX = Math.round(TARGET_WIDTH_CM * CM_TO_INCH * DPI);
    const TARGET_HEIGHT_PX = Math.round(TARGET_HEIGHT_CM * CM_TO_INCH * DPI);
    const ratioWidth = TARGET_WIDTH_CM;
    const ratioHeight = TARGET_HEIGHT_CM;

    // --- Ramka: detach + pozycjonowanie ---
    let frameVisible = false;
    let cropFrameIsDetached = false;
    let cropFramePrevStyles = null;

    function computeFrameRectForContainer(containerRect) {
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      const targetRatio = ratioWidth / ratioHeight;
      const margin = 0.85;
      const w = containerRect.width;
      const h = containerRect.height;
      let frameW, frameH;
      if (w && h) {
        if (w / h > targetRatio) {
          frameH = h * margin;
          frameW = frameH * targetRatio;
        } else {
          frameW = w * margin;
          frameH = frameW / targetRatio;
        }
      } else {
        if (vw / vh > targetRatio) {
          frameH = vh * margin;
          frameW = frameH * targetRatio;
        } else {
          frameW = vw * margin;
          frameH = frameW / targetRatio;
        }
      }
      const left = containerRect.left + (containerRect.width - frameW) / 2;
      const top  = containerRect.top  + (containerRect.height - frameH) / 2;
      return { frameW, frameH, left, top };
    }

    function detachCropFrameToBody() {
      if (cropFrameIsDetached) return;
      cropFramePrevStyles = {
        position: cropFrame.style.position || '',
        left: cropFrame.style.left || '',
        top: cropFrame.style.top || '',
        transform: cropFrame.style.transform || '',
        width: cropFrame.style.width || '',
        height: cropFrame.style.height || '',
        zIndex: cropFrame.style.zIndex || '',
        display: cropFrame.style.display || ''
      };
      document.body.appendChild(cropFrame);
      cropFrameIsDetached = true;
    }

    function reattachCropFrameToContainer() {
      if (!cropFrameIsDetached) return;
      mapContainer.appendChild(cropFrame);
      if (cropFramePrevStyles) {
        cropFrame.style.position = cropFramePrevStyles.position;
        cropFrame.style.left = cropFramePrevStyles.left;
        cropFrame.style.top = cropFramePrevStyles.top;
        cropFrame.style.transform = cropFramePrevStyles.transform;
        cropFrame.style.width = cropFramePrevStyles.width;
        cropFrame.style.height = cropFramePrevStyles.height;
        cropFrame.style.zIndex = cropFramePrevStyles.zIndex;
        cropFrame.style.display = cropFramePrevStyles.display;
      }
      cropFrameIsDetached = false;
      cropFramePrevStyles = null;
    }

    function updateCropFrame() {
      if (!frameVisible) return { ok: false };
      const contRect = mapContainer.getBoundingClientRect();
      const r = computeFrameRectForContainer(contRect);
      if (!r || !isFinite(r.frameW) || !isFinite(r.frameH)) return { ok: false };

      cropFrame.style.setProperty('display','block','important');
      cropFrame.style.setProperty('visibility','visible','important');
      cropFrame.style.setProperty('opacity','1','important');
      cropFrame.style.setProperty('z-index','2147483647','important');
      cropFrame.style.setProperty('border','3px solid orange','important');
      cropFrame.style.setProperty('box-shadow','0 0 0 9999px rgba(0,0,0,0.25)','important');

      detachCropFrameToBody();
      cropFrame.style.setProperty('position','fixed','important');
      cropFrame.style.setProperty('left', Math.round(r.left) + 'px','important');
      cropFrame.style.setProperty('top', Math.round(r.top) + 'px','important');
      cropFrame.style.setProperty('width', Math.round(r.frameW) + 'px','important');
      cropFrame.style.setProperty('height', Math.round(r.frameH) + 'px','important');
      cropFrame.style.setProperty('transform','none','important');

      return { ok: true, rect: r };
    }

    function ensureCropVisible() {
      const rect = cropFrame.getBoundingClientRect();
      const cs = window.getComputedStyle(cropFrame);
      if (cs.display === 'none' || rect.width === 0 || rect.height === 0) {
        cropFrame.style.setProperty('position','fixed','important');
        cropFrame.style.setProperty('left','50%','important');
        cropFrame.style.setProperty('top','50%','important');
        cropFrame.style.setProperty('transform','translate(-50%,-50%)','important');
        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        const margin = 0.85; const ratio = 15/10;
        let fw, fh;
        if (vw/vh > ratio) { fh = vh*margin; fw = fh*ratio; } else { fw = vw*margin; fh = fw/ratio; }
        cropFrame.style.setProperty('width', Math.round(fw)+'px','important');
        cropFrame.style.setProperty('height', Math.round(fh)+'px','important');
        cropFrame.style.setProperty('z-index','2147483647','important');
      }
    }

    function showFrame() {
      frameVisible = true;
      cropFrame.style.setProperty('display','block','important');
      cropFrame.style.setProperty('visibility','visible','important');
      cropFrame.style.setProperty('opacity','1','important');
      requestAnimationFrame(() => {
        updateCropFrame();
        ensureCropVisible();
      });
      btnFrame.textContent = 'Ukryj ramkę 10x15 cm';
    }

    function hideFrame() {
      frameVisible = false;
      reattachCropFrameToContainer();
      cropFrame.style.setProperty('display','none','important');
      btnFrame.textContent = 'Pokaż ramkę 10x15 cm';
    }

    btnFrame.addEventListener('click', () => { if (frameVisible) hideFrame(); else showFrame(); });
    map.on('move zoom', () => { if (frameVisible) updateCropFrame(); });
    window.addEventListener('resize', () => { if (frameVisible) updateCropFrame(); });

    // --- SVG highlight (budynki) ---
    let buildingRings = [];

    function clearHighlight() {
      buildingRings = [];
      while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
    }

    function clearStreets() {
      streetLayer.clearLayers();
    }

    // włącz/wyłącz widoczność ulic checkboxem
    chkStreets.addEventListener('change', () => {
      if (chkStreets.checked) {
        if (!map.hasLayer(streetLayer)) streetLayer.addTo(map);
      } else {
        if (map.hasLayer(streetLayer)) map.removeLayer(streetLayer);
      }
    });

    function hexToRgba(hex, alpha = 0.35) {
      const c = hex.replace('#','');
      const bigint = parseInt(c, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }
    function getActiveColor() {
      return (activeColorPicker && activeColorPicker.value) || '#b36b00';
    }

    function updateHighlightSvg() {
      while (highlightSvg.firstChild) highlightSvg.removeChild(highlightSvg.firstChild);
      if (!buildingRings.length) return;

      const color = getActiveColor();
      const fill = hexToRgba(color, 0.35);
      const stroke = color;

      for (const ring of buildingRings) {
        if (!ring || ring.length < 3) continue;
        const pts = ring.map(([la, lo]) => {
          const p = map.latLngToContainerPoint([la, lo]);
          return `${p.x},${p.y}`;
        }).join(' ');
        const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute('points', pts);
        poly.setAttribute('fill', fill);
        poly.setAttribute('stroke', stroke);
        poly.setAttribute('stroke-width', '3');
        highlightSvg.appendChild(poly);
      }
    }
    map.on('move zoom', updateHighlightSvg);

    // --- pomocnicza funkcja: przybliżone pole wielokąta ---
    function polygonAreaApprox(coords) {
      let area = 0;
      for (let i = 0; i < coords.length; i++) {
        const [y1, x1] = coords[i];
        const [y2, x2] = coords[(i + 1) % coords.length];
        area += x1 * y2 - x2 * y1;
      }
      return Math.abs(area) / 2;
    }

    // --- Geocoding + Overpass (budynki) ---
    async function geocode(address) {
      const url = 'https://nominatim.openstreetmap.org/search?' +
        new URLSearchParams({ format:'json', limit:'1', q: address, polygon_geojson: 1 });
      const resp = await fetch(url, { headers: { 'Accept-Language': 'pl' } });
      if (!resp.ok) throw new Error('Błąd geokodowania');
      const data = await resp.json();
      if (!data.length) return null;
      return [parseFloat(data[0].lat), parseFloat(data[0].lon), data[0]];
    }

    async function fetchBuildingWays(lat, lon, radius = 60) {
      const query = `
[out:json][timeout:25];
(
  way["building"](around:${radius},${lat},${lon});
  relation["building"](around:${radius},${lat},${lon});
);
(._;>;);
out body;
`;
      const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
      if (!resp.ok) throw new Error('Błąd Overpass');
      const data = await resp.json();
      return data.elements || [];
    }

    function normalize(s='') {
      return String(s).trim().toLowerCase()
        .replace(/\./g,'')
        .replace(/\b(ulica|ul|al|aleja|al\.)\b/g,'')
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ').trim();
    }

    function pointInRing(lon, lat, ring) {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][1], yi = ring[i][0];
        const xj = ring[j][1], yj = ring[j][0];
        const intersect = ((yi > lat) !== (yj > lat)) &&
          (lon < (xj - xi) * (lat - yi) / (yj - yi + 0.0) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // "Ulica 123" -> wyciągnij "Ulica"
    function extractStreet(s) {
      const m = String(s).trim().match(/^(.+?)\s+\d/);
      return m ? m[1].trim() : null;
    }

    // =========================================================
    //  U L I C E  (ZAKRES OD–DO) – osobny moduł
    // =========================================================
    function opEscape(s) {
      return String(s).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    function boundsToBboxObj(bounds) {
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();
      return { south: sw.lat, west: sw.lng, north: ne.lat, east: ne.lng };
    }

    async function fetchHighwayWaysByNameBBox(streetName, bbox) {
      const { south, west, north, east } = bbox;
      const nn = opEscape(streetName);
      const query = `
[out:json][timeout:25];
(
  way["highway"]["name"="${nn}"](${south},${west},${north},${east});
);
out geom;
`;
      const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
      if (!resp.ok) throw new Error('Błąd Overpass (ulice)');
      const data = await resp.json();
      return (data.elements || []).filter(e => e.type === 'way' && Array.isArray(e.geometry) && e.geometry.length >= 2);
    }

    // parsowanie: "Piotrkowska 10-20" / "Piotrkowska 10 do 20"
    function parseStreetRanges(raw) {
      const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
      const out = [];
      for (const p of parts) {
        const m = p.match(/^(.*?)(\d+[A-Za-z0-9\/\-]*)\s*(?:-|–|—|\bdo\b)\s*(\d+[A-Za-z0-9\/\-]*)\s*$/i);
        if (!m) continue;
        const street = m[1].trim();
        const from = m[2].trim();
        const to = m[3].trim();
        if (!street || !from || !to) continue;
        out.push({ street, from, to, raw: p });
      }
      return out;
    }

    // dystans (metry) – haversine
    function distMeters(a, b) {
      const R = 6371000;
      const toRad = (d) => d * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const sin1 = Math.sin(dLat/2), sin2 = Math.sin(dLon/2);
      const h = sin1*sin1 + Math.cos(lat1)*Math.cos(lat2)*sin2*sin2;
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
    }

    // projekcja punktu na odcinek (aproksymacja equirect)
    function projectPointToSegment(P, A, B) {
      const R = 6371000;
      const lat0 = (A.lat + B.lat + P.lat) / 3 * Math.PI/180;
      const cos0 = Math.cos(lat0);

      const toXY = (ll) => {
        const x = (ll.lng * Math.PI/180) * R * cos0;
        const y = (ll.lat * Math.PI/180) * R;
        return { x, y };
      };
      const toLL = (x, y) => {
        const lat = (y / R) * 180/Math.PI;
        const lng = (x / (R * cos0)) * 180/Math.PI;
        return L.latLng(lat, lng);
      };

      const p = toXY(P), a = toXY(A), b = toXY(B);
      const abx = b.x - a.x, aby = b.y - a.y;
      const apx = p.x - a.x, apy = p.y - a.y;
      const ab2 = abx*abx + aby*aby;
      let t = ab2 ? (apx*abx + apy*aby) / ab2 : 0;
      t = Math.max(0, Math.min(1, t));
      const x = a.x + t*abx;
      const y = a.y + t*aby;
      const proj = toLL(x, y);

      const d = Math.hypot(p.x - x, p.y - y);
      return { proj, t, d };
    }

    function toKey(ll) {
      // zaokrąglenie, żeby skleić “prawie te same” punkty
      return `${ll.lat.toFixed(6)},${ll.lng.toFixed(6)}`;
    }

    // prosta kolejka priorytetowa (kopiec)
    class MinHeap {
      constructor() { this.a = []; }
      push(item) {
        this.a.push(item);
        this._up(this.a.length - 1);
      }
      pop() {
        if (!this.a.length) return null;
        const top = this.a[0];
        const last = this.a.pop();
        if (this.a.length) {
          this.a[0] = last;
          this._down(0);
        }
        return top;
      }
      _up(i) {
        while (i > 0) {
          const p = (i - 1) >> 1;
          if (this.a[p].d <= this.a[i].d) break;
          [this.a[p], this.a[i]] = [this.a[i], this.a[p]];
          i = p;
        }
      }
      _down(i) {
        const n = this.a.length;
        for (;;) {
          let l = i*2+1, r = l+1, m = i;
          if (l < n && this.a[l].d < this.a[m].d) m = l;
          if (r < n && this.a[r].d < this.a[m].d) m = r;
          if (m === i) break;
          [this.a[m], this.a[i]] = [this.a[i], this.a[m]];
          i = m;
        }
      }
    }

    function dijkstra(adj, startK, endK) {
      const dist = new Map();
      const prev = new Map();
      const heap = new MinHeap();

      dist.set(startK, 0);
      heap.push({ k: startK, d: 0 });

      while (true) {
        const cur = heap.pop();
        if (!cur) break;
        const { k, d } = cur;
        if (d !== dist.get(k)) continue;
        if (k === endK) break;

        const nbrs = adj.get(k);
        if (!nbrs) continue;

        for (const { to, w } of nbrs) {
          const nd = d + w;
          if (nd < (dist.get(to) ?? Infinity)) {
            dist.set(to, nd);
            prev.set(to, k);
            heap.push({ k: to, d: nd });
          }
        }
      }

      if (!dist.has(endK)) return null;

      const path = [];
      let k = endK;
      while (k != null) {
        path.push(k);
        if (k === startK) break;
        k = prev.get(k);
      }
      path.reverse();
      return path;
    }

    async function highlightOneStreetRange(range, requestId) {
      const street = range.street;

      // 1) geokoduj końce
      const a1 = `Łódź, ${street} ${range.from}`;
      const a2 = `Łódź, ${street} ${range.to}`;

      const g1 = await geocode(a1);
      if (requestId !== lastStreetRequestId) return null;
      const g2 = await geocode(a2);
      if (requestId !== lastStreetRequestId) return null;

      if (!g1 || !g2) return { ok:false, reason:`Brak geokodowania: ${range.raw}` };

      const p1 = L.latLng(g1[0], g1[1]);
      const p2 = L.latLng(g2[0], g2[1]);

      // 2) pobierz ulicę w bbox wokół obu punktów
      const bounds = L.latLngBounds([p1, p2]).pad(0.55);
      const bbox = boundsToBboxObj(bounds);

      const ways = await fetchHighwayWaysByNameBBox(street, bbox);
      if (requestId !== lastStreetRequestId) return null;

      if (!ways.length) return { ok:false, reason:`Brak geometrii OSM dla: ${street}` };

      // 3) zbuduj graf
      const adj = new Map();        // key -> [{to,w}]
      const coordsByKey = new Map();// key -> L.LatLng

      function ensureNode(ll) {
        const k = toKey(ll);
        if (!coordsByKey.has(k)) coordsByKey.set(k, ll);
        if (!adj.has(k)) adj.set(k, []);
        return k;
      }
      function addEdge(k1, k2, w) {
        adj.get(k1).push({ to: k2, w });
      }

      // normalne krawędzie z geometrii
      for (const w of ways) {
        const pts = w.geometry.map(p => L.latLng(p.lat, p.lon));
        for (let i = 0; i < pts.length - 1; i++) {
          const A = pts[i], B = pts[i+1];
          const kA = ensureNode(A);
          const kB = ensureNode(B);
          const wAB = distMeters(A, B);
          addEdge(kA, kB, wAB);
          addEdge(kB, kA, wAB);
        }
      }

      // 4) znajdź najbliższe odcinki dla p1 i p2 (projekcja)
      function findBestProjection(P) {
        let best = null;
        for (const w of ways) {
          const pts = w.geometry.map(p => L.latLng(p.lat, p.lon));
          for (let i = 0; i < pts.length - 1; i++) {
            const A = pts[i], B = pts[i+1];
            const pr = projectPointToSegment(P, A, B);
            if (!best || pr.d < best.d) best = { ...pr, A, B };
          }
        }
        return best;
      }

      const pr1 = findBestProjection(p1);
      const pr2 = findBestProjection(p2);
      if (!pr1 || !pr2) return { ok:false, reason:`Nie udało się dopasować odcinka: ${range.raw}` };

      const kA1 = ensureNode(pr1.A);
      const kB1 = ensureNode(pr1.B);
      const kP1 = ensureNode(pr1.proj);

      const kA2 = ensureNode(pr2.A);
      const kB2 = ensureNode(pr2.B);
      const kP2 = ensureNode(pr2.proj);

      // połącz projekcje z końcami segmentu
      const wP1A = distMeters(pr1.proj, pr1.A), wP1B = distMeters(pr1.proj, pr1.B);
      addEdge(kP1, kA1, wP1A); addEdge(kA1, kP1, wP1A);
      addEdge(kP1, kB1, wP1B); addEdge(kB1, kP1, wP1B);

      const wP2A = distMeters(pr2.proj, pr2.A), wP2B = distMeters(pr2.proj, pr2.B);
      addEdge(kP2, kA2, wP2A); addEdge(kA2, kP2, wP2A);
      addEdge(kP2, kB2, wP2B); addEdge(kB2, kP2, wP2B);

      // 5) dijkstra po grafie
      const pathKeys = dijkstra(adj, kP1, kP2);
      if (!pathKeys || pathKeys.length < 2) {
        return { ok:false, reason:`Brak ścieżki po ulicy dla: ${range.raw}` };
      }

      const path = pathKeys.map(k => coordsByKey.get(k)).filter(Boolean).map(ll => [ll.lat, ll.lng]);

      // 6) rysuj
      const line = L.polyline(path, {
        color: '#ff0000',
        weight: 6,
        opacity: 0.95,
        lineCap: 'round',
        lineJoin: 'round'
      }).addTo(streetLayer);

      return { ok:true, line };
    }

    let lastStreetRequestId = 0;

    async function showStreetsRanges() {
      const raw = uliceInput.value.trim();
      if (!raw) { setStatus('Podaj ulicę i zakres, np. "Piotrkowska 10-20".', true); return; }

      const ranges = parseStreetRanges(raw);
      if (!ranges.length) {
        setStatus('Nie rozpoznano zakresów. Format: "Ulica 10-20, Inna 111-125A".', true);
        return;
      }

      if (chkStreets.checked) {
        if (!map.hasLayer(streetLayer)) streetLayer.addTo(map);
      } else {
        // rysujemy, ale warstwa może być ukryta
      }

      clearStreets();
      const requestId = ++lastStreetRequestId;

      setStatus(`Rysuję ulice (zakresy): ${ranges.length}…`);

      let drawn = 0;
      let fail = 0;
      const allBounds = [];

      for (const r of ranges) {
        try {
          const res = await highlightOneStreetRange(r, requestId);
          if (requestId !== lastStreetRequestId) return;

          if (res && res.ok && res.line) {
            drawn++;
            allBounds.push(res.line.getBounds());
          } else if (res && res.ok === false) {
            fail++;
          } else {
            // anulowane
            return;
          }
        } catch (e) {
          fail++;
        }
        await sleep(250);
      }

      if (drawn === 0) {
        setStatus('Nie udało się narysować żadnego zakresu ulic.', true);
        return;
      }

      // ustaw widok (stały zoom, tylko centrowanie)
      const merged = allBounds.reduce((b, nb) => b.extend(nb), allBounds[0]);
      map.setView(merged.getCenter(), FIXED_ZOOM, { animate: true });

      setStatus(`Ulice narysowane: ${drawn}. Błędy: ${fail}.`);
    }

    btnStreets.addEventListener('click', showStreetsRanges);
    uliceInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') showStreetsRanges();
    });

    // =========================================================
    //  B U D Y N K I  – zostaje jak było (bez auto-ulic)
    // =========================================================
    let lastRequestId = 0;

    async function showBuildingsForAddresses() {
      const raw = adresInput.value.trim();
      if (!raw) { setStatus('Podaj adresy.', true); return; }

      setStatus('Szukam…');
      clearHighlight();
      const myId = ++lastRequestId;

      const segments = raw.split(',').map(s => s.trim()).filter(Boolean);

      const addresses = [];
      let lastStreet = null;

      const isHouseNumberOnly = (s) =>
        /^\d+[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż0-9\-\/]*$/.test(s);

      const looksLikeStreetAndNumber = (s) =>
        /[A-Za-zĄąĆćĘęŁłŃńÓóŚśŹźŻż]/.test(s) && /\d/.test(s) && !!extractStreet(s);

      for (const part of segments) {
        if (looksLikeStreetAndNumber(part)) {
          const st = extractStreet(part);
          if (st) lastStreet = st;
          addresses.push(part);
          continue;
        }
        if (lastStreet && isHouseNumberOnly(part)) {
          addresses.push(`${lastStreet} ${part}`);
          continue;
        }
        addresses.push(part);
      }

      const finalAddresses = addresses.map(a => {
        const lower = a.toLowerCase();
        if (!lower.includes('łódź') && !lower.includes('lodz')) return 'Łódź, ' + a;
        return a;
      });

      for (const addr of finalAddresses) {
        try {
          const geo = await geocode(addr);
          if (!geo) { continue; }
          const center = [geo[0], geo[1]];
          const nomiObj = geo[2];
          if (myId !== lastRequestId) return;

          // Nominatim polygon tylko gdy NIE jest to Bartoka 1
          let usedFromNominatim = false;
          if (nomiObj && nomiObj.geojson && !/bartoka\s+1\b/i.test(addr)) {
            const g = nomiObj.geojson;
            if (g.type === 'Polygon') {
              const ring = g.coordinates[0].map(([lon, lat]) => [lat, lon]);
              buildingRings.push(ring);
              usedFromNominatim = true;
            } else if (g.type === 'MultiPolygon') {
              for (const poly of g.coordinates) {
                const ring = poly[0].map(([lon, lat]) => [lat, lon]);
                buildingRings.push(ring);
              }
              usedFromNominatim = true;
            }
            if (usedFromNominatim) {
              if (myId !== lastRequestId) return;
              continue;
            }
          }

          // Overpass
          const elems = await fetchBuildingWays(center[0], center[1], 60);
          if (myId !== lastRequestId) return;
          if (!elems.length) { continue; }

          const nodeMap = new Map();
          for (const el of elems) if (el.type === 'node') nodeMap.set(el.id, [el.lat, el.lon]);

          const rings = [];
          const ways = elems.filter(el => el.type === 'way');
          for (const w of ways) {
            const coords = w.nodes.map(id => nodeMap.get(id)).filter(Boolean);
            if (coords.length >= 3) {
              rings.push({ coords, tags: w.tags || {}, area: polygonAreaApprox(coords) });
            }
          }

          const relations = elems.filter(el => el.type === 'relation' && el.tags && (el.tags.type === 'multipolygon' || el.tags.building));
          for (const rel of relations) {
            if (!rel.members) continue;
            const outerMembers = rel.members.filter(m => m.type === 'way' && (m.role === 'outer' || m.role === ''));
            for (const m of outerMembers) {
              const way = elems.find(e => e.type === 'way' && e.id === m.ref);
              if (!way) continue;
              const coords = way.nodes.map(id => nodeMap.get(id)).filter(Boolean);
              if (coords.length >= 3) {
                rings.push({ coords, tags: way.tags || {}, area: polygonAreaApprox(coords) });
              }
            }
          }

          if (rings.length === 0) { continue; }

          const m = addr.match(/(.*)\s+(\d+[a-zA-Z0-9\-\/]*)$/);
          const wanted = {};
          if (m) { wanted.street = normalize(m[1]); wanted.number = normalize(m[2]); }

          const matches = [];
          for (const r of rings) {
            const tags = r.tags || {};
            let accept = false;

            if (tags['addr:housenumber'] || tags['addr:street']) {
              const tagNum = normalize(tags['addr:housenumber'] || '');
              const tagStreet = normalize(tags['addr:street'] || tags['addr:street:name'] || '');
              if (wanted.number && wanted.street && tagNum === wanted.number && tagStreet === wanted.street) {
                accept = true;
              }
            }
            if (!accept) {
              if (pointInRing(center[1], center[0], r.coords)) accept = true;
            }
            if (accept) matches.push(r);
          }

          let finalPicked = [];
          if (matches.length) {
            if (wanted.street === 'bartoka' && wanted.number === '1') {
              let largest = matches[0];
              for (const r of matches) if (r.area > largest.area) largest = r;
              finalPicked = [largest.coords];
            } else {
              finalPicked = matches.map(r => r.coords);
            }
          } else {
            const wayInfos = rings.map(rr => {
              const coords = rr.coords;
              let sumLat=0,sumLon=0;
              for (const [la,lo] of coords){ sumLat+=la; sumLon+=lo; }
              const cLat = sumLat/coords.length, cLon = sumLon/coords.length;
              const dLat = cLat - center[0], dLon = cLon - center[1];
              return { coords, dist2: dLat*dLat + dLon*dLon };
            }).sort((a,b)=>a.dist2-b.dist2);
            if (wayInfos.length) finalPicked.push(wayInfos[0].coords);
          }

          for (const p of finalPicked) buildingRings.push(p);

        } catch (err) {
          // cicho
        }
      }

      if (!buildingRings.length) {
        setStatus('Nie znaleziono precyzyjnych dopasowań dla podanych adresów.', true);
        return;
      }

      updateHighlightSvg();

      const tmpPoly = L.polygon([].concat(...buildingRings));
      const focusBounds = tmpPoly.getBounds();
      map.setView(focusBounds.getCenter(), FIXED_ZOOM, { animate: true });

      setStatus(`Zaznaczono ${buildingRings.length} budynków (${addresses.length} adresów).`);
    }

    btnShow.addEventListener('click', async () => {
      clearHighlight();
      await showBuildingsForAddresses();
    });

    adresInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        clearHighlight();
        showBuildingsForAddresses();
      }
    });

    // --- Eksport PNG 10x15 cm @300 DPI ---
    const HTML2CANVAS_SCALE = 3;

    async function saveFramePng() {
      if (!frameVisible) { setStatus('Najpierw włącz ramkę kopiowania.', true); return; }
      try {
        setStatus('Generuję obraz wysokiej rozdzielczości…');
        const fullCanvas = await html2canvas(mapContainer, { useCORS: true, logging: false, scale: HTML2CANVAS_SCALE });

        const frameRect = cropFrame.getBoundingClientRect();
        const contRect = mapContainer.getBoundingClientRect();

        const sx = frameRect.left - contRect.left;
        const sy = frameRect.top  - contRect.top;
        const sw = frameRect.width;
        const sh = frameRect.height;

        const scaleX = fullCanvas.width  / mapContainer.clientWidth;
        const scaleY = fullCanvas.height / mapContainer.clientHeight;

        const sxScaled = sx * scaleX;
        const syScaled = sy * scaleY;
        const swScaled = sw * scaleX;
        const shScaled = sh * scaleY;

        const outCanvas = document.createElement('canvas');
        outCanvas.width = TARGET_WIDTH_PX;
        outCanvas.height = TARGET_HEIGHT_PX;
        const ctx = outCanvas.getContext('2d');

        ctx.drawImage(fullCanvas, sxScaled, syScaled, swScaled, shScaled, 0, 0, TARGET_WIDTH_PX, TARGET_HEIGHT_PX);

        const dataUrl = outCanvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;

        let baseName = (filenameInput.value || 'map_10x15cm_300dpi').trim();
        if (!baseName.toLowerCase().endsWith('.png')) baseName += '.png';
        a.download = baseName;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        setStatus('Zapisano PNG.');
      } catch (err) {
        setStatus('Błąd tworzenia PNG. Użyj ręcznego zrzutu jako fallback.', true);
      }
    }

    btnSave.addEventListener('click', saveFramePng);

    function handleColorInput(e) {
      activeColorPicker = e.target;
      updateHighlightSvg();
    }

    colorPicker1.addEventListener('input', handleColorInput);
    colorPicker2.addEventListener('input', handleColorInput);

    colorPicker1.addEventListener('click', () => { activeColorPicker = colorPicker1; updateHighlightSvg(); });
    colorPicker2.addEventListener('click', () => { activeColorPicker = colorPicker2; updateHighlightSvg(); });

  </script>
</body>
</html>
